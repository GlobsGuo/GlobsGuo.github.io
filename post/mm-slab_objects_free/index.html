<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>mm-slab对象的回收 - Globs&#39; Catchall</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Globs Guo" /><meta name="description" content="本文仍然以slab cache kmalloc_caches 为例，结合 kfree 函数的实现，说明slab对象的回收过程。 1. kfree 通过 kfree 函数释放 kmalloc 申请的内存时，对应的函数定义在 mm/slub.c 中。 void kfree(const void *x) {" />






<meta name="generator" content="Hugo 0.58.3 with theme even" />


<link rel="canonical" href="https://globsguo.github.io/post/mm-slab_objects_free/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="mm-slab对象的回收" />
<meta property="og:description" content="本文仍然以slab cache kmalloc_caches 为例，结合 kfree 函数的实现，说明slab对象的回收过程。 1. kfree 通过 kfree 函数释放 kmalloc 申请的内存时，对应的函数定义在 mm/slub.c 中。 void kfree(const void *x) {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://globsguo.github.io/post/mm-slab_objects_free/" />
<meta property="article:published_time" content="2019-10-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-10-21T00:00:00+00:00" />
<meta itemprop="name" content="mm-slab对象的回收">
<meta itemprop="description" content="本文仍然以slab cache kmalloc_caches 为例，结合 kfree 函数的实现，说明slab对象的回收过程。 1. kfree 通过 kfree 函数释放 kmalloc 申请的内存时，对应的函数定义在 mm/slub.c 中。 void kfree(const void *x) {">


<meta itemprop="datePublished" content="2019-10-21T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-10-21T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="5559">



<meta itemprop="keywords" content="kernel-sources,memory,kmem_cache,slub,kmalloc_caches,kmalloc,kfree,slab_free," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="mm-slab对象的回收"/>
<meta name="twitter:description" content="本文仍然以slab cache kmalloc_caches 为例，结合 kfree 函数的实现，说明slab对象的回收过程。 1. kfree 通过 kfree 函数释放 kmalloc 申请的内存时，对应的函数定义在 mm/slub.c 中。 void kfree(const void *x) {"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Globs&#39; Catchall</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Globs&#39; Catchall</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">mm-slab对象的回收</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-10-21 </span>
        
          <span class="more-meta"> 5559 words </span>
          <span class="more-meta"> 12 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#1-kfree">1. kfree</a></li>
<li><a href="#2-slab-free-mm-slub-c">2. slab_free( <em>mm/slub.c</em> )</a></li>
<li><a href="#3-slab-free-mm-slub-c">3. __slab_free( <em>mm/slub.c</em> )</a></li>
<li><a href="#4-slab的操作函数">4. slab的操作函数</a>
<ul>
<li><a href="#4-1-put-cpu-partial">4.1. <code>put_cpu_partial</code></a>
<ul>
<li><a href="#4-1-1-unfreeze-partials">4.1.1. <code>unfreeze_partials</code></a></li>
</ul></li>
<li><a href="#4-2-add-partial-remove-partial-remove-full">4.2. <code>add_partial</code> / <code>remove_partial</code> / <code>remove_full</code></a></li>
<li><a href="#4-3-discard-slab">4.3. <code>discard_slab</code></a></li>
</ul></li>
<li><a href="#5-deactivate-slab">5. deactivate_slab</a></li>
<li><a href="#6-总结">6. 总结</a></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<p>本文仍然以slab cache <strong>kmalloc_caches</strong> 为例，结合 <code>kfree</code> 函数的实现，说明slab对象的回收过程。</p>

<h1 id="1-kfree">1. kfree</h1>

<p>通过 <code>kfree</code> 函数释放 <code>kmalloc</code> 申请的内存时，对应的函数定义在 <em>mm/slub.c</em> 中。</p>

<pre><code class="language-C">void kfree(const void *x)
{
    struct page *page;
    void *object = (void *)x;

    trace_kfree(_RET_IP_, x);
    /* 地址为空直接返回 */
    if (unlikely(ZERO_OR_NULL_PTR(x)))
        return;
    /* 通过内核虚拟地址获取对应的struct page * */
    page = virt_to_head_page(x);
    /* slab分配器没有管理这个内存页 */
    if (unlikely(!PageSlab(page))) {
        BUG_ON(!PageCompound(page));
        kfree_hook(x);
        /* 直接通过伙伴系统释放内存页 */
        __free_kmem_pages(page, compound_order(page));
        return;
    }
    /* struct page中包含内存页的slab信息，包括该内存页
       所属的slab cache，*/
    slab_free(page-&gt;slab_cache, page, object, _RET_IP_);
}
EXPORT_SYMBOL(kfree);
</code></pre>

<h1 id="2-slab-free-mm-slub-c">2. slab_free( <em>mm/slub.c</em> )</h1>

<p>如果 <code>kfree</code> 的参数地址所在的页面属于slab分配器，通过 <code>slab_free</code> 函数释放。 <code>slab_free</code> 函数也有两个分支，快路径和慢路径。</p>

<p>如果 <code>kfree</code> 的对象属于当前的cpu slab，执行快路径；否则执行慢路径。</p>

<pre><code class="language-C">static __always_inline void slab_free(struct kmem_cache *s,
            struct page *page, void *x, unsigned long addr)
{
    void **object = (void *)x;
    struct kmem_cache_cpu *c;
    unsigned long tid;

    slab_free_hook(s, x);

redo:
    /*
     * Determine the currently cpus per cpu slab.
     * The cpu may change afterward. However that does not matter since
     * data is retrieved via this pointer. If we are on the same cpu
     * during the cmpxchg then the free will succedd.
     */
    preempt_disable();
    c = this_cpu_ptr(s-&gt;cpu_slab);

    tid = c-&gt;tid;
    preempt_enable();
    /*
     释放的对象所在的内存页刚好是当前CPU正在使用的
     slab，执行快路径，只需要添加到freelist中 */
    if (likely(page == c-&gt;page)) {
        /*
         设置要释放的对象指向当前的空闲对象，即把释放的对象
         添加到CPU的freelist中 */
        set_freepointer(s, object, c-&gt;freelist);
        /*
         更新slab cache的cpu_slab变量，指向
         最新的freelist，并且更新tid */
        if (unlikely(!this_cpu_cmpxchg_double(
                s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,
                c-&gt;freelist, tid,
                object, next_tid(tid)))) {

            note_cmpxchg_failure(&quot;slab_free&quot;, s, tid);
            goto redo;
        }
        stat(s, FREE_FASTPATH);
    } else
        /*
         page不是当前CPU正在分配对象的slab，执行慢路径。
         可能是以下情况：
         1. 释放的对象属于当前CPU的partial表
         2. 释放的对象属于其他CPU的slab  */
        __slab_free(s, page, x, addr);

}
</code></pre>

<h1 id="3-slab-free-mm-slub-c">3. __slab_free( <em>mm/slub.c</em> )</h1>

<p>慢路径释放slab时，涉及到多个名称相近的变量，先对这些变量进行说明。</p>

<ul>
<li><p><strong>struct kmem_cache</strong> —— 描述一个slab cache：</p>

<ul>
<li><code>unsigned long min_partial</code><br />
node结点中部分空slab缓冲区数量不能小于这个值，如果小于这个值，空闲slab缓冲区则不能够进行释放，而是将空闲slab加入到node结点的部分空slab链表中。<br /></li>
<li><code>int cpu_partial</code><br />
同min_partial类似，只是这个值表示的是对象的数量，而不是部分空slab数量，即CPU的partial对象数量不能小于这个值，小于的情况下要去对应node结点的部分空链表中获取若干个部分空slab；否则在 <code>put_cpu_partial</code> 函数中进行解冻操作。</li>
</ul></li>

<li><p><strong>struct kmem_cache_cpu</strong> —— 描述一个CPU的slab cache：</p>

<ul>
<li><code>void **freelist</code><br />
指向下一个空闲的对象</li>
<li><code>struct page *partial</code><br />
CPU的部分空slab链表，放到CPU的部分空slab链表中的slab会被冻结，而放入node中的部分空slab链表则解冻，冻结标志在slab缓冲区描述符( <strong>struct page</strong> )中<br /></li>
<li><code>struct page *page</code><br />
当前分配对象的slab</li>
</ul></li>

<li><p><strong>struct kmem_cache_node</strong> —— 描述一个节点的slab cache：</p>

<ul>
<li><code>unsigned long nr_partial</code><br />
节点中部分空slab的数量</li>
<li><code>struct list_head partial</code><br />
保存部分空slab的链表</li>
</ul></li>

<li><p><strong>struct page</strong> —— 描述一个slab：</p>

<ul>
<li><code>void *freelist</code><br />
第一个空闲的对象</li>
<li><code>unsigned inuse:16</code><br />
slab中已经分配的对象的数量</li>
<li><code>unsigned frozen:1</code><br />
被冻结的slab不属于任何链表，不会进行列表的管理操作。<br />
只有冻结slab的CPU可以执行列表操作——其他的CPU可以往freelist中添加对象，但是只有冻结slab的CPU可以从freelist中获取对象。因此， <code>slab_free</code> 函数会跳过列表的相关操作。<br />
被冻结的slab主要用于特定目的，比如响应特定CPU的分配请求。<br />
<strong>frozen</strong> 标志用来判断某一个slab(即内存页)是否已经被某个CPU用作slab cache，即属于某个 <strong>kmem_cache_cpu</strong>。</li>
</ul></li>
</ul>

<p>和快路径 <code>slab_free</code> 不同，执行慢路径的原因是 <code>kfree</code> 释放的对象所属的内存页不是当前CPU正在分配对象的slab。<br />
因此，函数释放对象的时候修改的是 <strong>struct page</strong> 内的 <strong>freelist</strong> 指针，而不是CPU的freelist。</p>

<pre><code class="language-C">static void __slab_free(struct kmem_cache *s, struct page *page,
            void *x, unsigned long addr)
{
    void *prior;
    void **object = (void *)x;
    int was_frozen;
    struct page new;
    unsigned long counters;
    struct kmem_cache_node *n = NULL;
    unsigned long uninitialized_var(flags);

    ...
    /* do-while循环保证更改成功 */
    do {
        if (unlikely(n)) {
            spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);
            n = NULL;
        }
        prior = page-&gt;freelist;
        counters = page-&gt;counters;
        set_freepointer(s, object, prior);
        /*
         counters的赋值操作会将和其位于相同union内的
         inuse，objects，frozen字段赋值 */
        new.counters = counters;
        was_frozen = new.frozen;
        new.inuse--;
        /*
         !new.inuse = true，slab中没有分配出去的对象，目前我
         只想到了一种情况，即当前释放的对象是slab中的最后一个
         对象，释放之后slab为空。
         !prior = true，slab中没有可用的对象，即slab为满。
         !was_frozen = true，slab没有被冻结，即不属于某一个CPU
         的slab cache  */
        if ((!new.inuse || !prior) &amp;&amp; !was_frozen) {
            /*
             slab为满，释放当前对象后会变成partial，而且
             不属于某一个CPU的slab cache，将其冻结，使其
             属于当前CPU的slab cache */
            if (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) {
                new.frozen = 1;
            } else {
                /*
                 释放当前的对象后slab为空，先获取节点信息，
                 并且获取修改slab list所需的锁，以便之后
                 释放空slab */
                n = get_node(s, page_to_nid(page));
                /*
                 只有当前slab为空时才需要获取锁，并且在执行
                 释放操作后释放锁 */
                spin_lock_irqsave(&amp;n-&gt;list_lock, flags);
            }
        }
    } while (!cmpxchg_double_slab(s, page,
        prior, counters,
        object, new.counters,
        &quot;__slab_free&quot;));
    /*
     n为空的可能性较大，即当前释放的对象是slab中的最后一个对象
     的可能性较小。其他的可能情况为：
     1. slab已满，并且slab不属于某个CPU
     2. slab已经属于某个CPU
     3. 无论slab是否属于某个CPU，slab的freelist不为空，且inuse
     字段不为0 */
    if (likely(!n)) {
        /*
         刚刚执行的冻结操作，将内存页添加到当前CPU的slab
         cache的partial表。
         这里put_cpu_partial函数将新的slab添加到partial
         表时，如果当前CPU中已有的partial对象大于slab
         cache的cpu_partial值，就会将当前CPU中的所有的
         partial slab解冻，并且在节点中的partial slab
         的数量不小于slab cache的cpu_partial值的情况下，
         释放解冻的slab；否则将解冻的slab添加到节点的
         partial表中。 */
        if (new.frozen &amp;&amp; !was_frozen) {
            put_cpu_partial(s, page, 1);
            stat(s, CPU_PARTIAL_FREE);
        }
        /*
         slab已经属于其他CPU的slab cache，当前的CPU不是冻结
         slab的CPU，无法执行其他的操作；这种情况下也没有获取
         锁的操作，因此也不需要释放  */
        if (was_frozen)
            stat(s, FREE_FROZEN);
        return;
    }
    /*
     释放当前对象后slab为空，并且节点的partial slab数量仍然
     大于slab cache中的最小阈值，可以直接将slab释放 */
    if (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt; s-&gt;min_partial))
        goto slab_empty;

    /* slab从full变为partial */
    if (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) {
        if (kmem_cache_debug(s))
            remove_full(s, n, page);
        add_partial(n, page, DEACTIVATE_TO_TAIL);
        stat(s, FREE_ADD_PARTIAL);
    }
    spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);
    return;

slab_empty:
    /* 当前释放的对象是slab中的最后一个对象 */
    if (prior) {
        /* 当前slab有多个对象 */
        remove_partial(n, page);
        stat(s, FREE_REMOVE_PARTIAL);
    } else {
        /* 当前slab只有一个对象，导致位于full表 */
        remove_full(s, n, page);
    }
    /* 释放获取的锁 */
    spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);
    stat(s, FREE_SLAB);
    /* 释放slab */
    discard_slab(s, page);
}
</code></pre>

<h1 id="4-slab的操作函数">4. slab的操作函数</h1>

<p><code>__slab_free</code> 函数调用了多个操作slab的函数，包括 <code>put_cpu_partial</code> ， <code>add_partial</code> ， <code>remove_partial</code> ， <code>remove_full</code> ， <code>discard_slab</code> 。</p>

<h2 id="4-1-put-cpu-partial">4.1. <code>put_cpu_partial</code></h2>

<p><code>__slab_free</code> 函数执行时，如果如果slab不属于任何CPU的slab cache，就会在释放对象后把slab添加到当前CPU的slab cache中，作为partial slab。</p>

<p><strong>struct kmem_cache</strong> 结构体的 <strong>struct kmem_cache_cpu __percpu *cpu_slab</strong> 成员，其 <strong>struct page *partial</strong> 包含CPU的所有partial slab。<br />
这些slab通过 <strong>struct page</strong> 的 <strong>struct page *next</strong> 成员链接；每个slab(page)包含partial链表中剩余partial slabs所有对象的数量，即 <strong>pobjects</strong> ，还包含剩余的partial slabs的数量，即 <strong>pages</strong> 。<br />
也就是说，每个CPU的slab cache包含的partial slab都保存在一个链表中，这个链表通过 <code>*next</code> 指针链接；链表中的第一个slab包含链表中对象的总数和slab的总数，第二个slab包含除了第一个slab外对象的总数和slab的总数。</p>

<p><code>put_cpu_partial</code> 函数的原型如下：<br />
<code>static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);</code> 。<br />
<strong>s</strong> 是当前正在操作的slab cache， <strong>page</strong> 是要添加到partial list的slab， <strong>drain</strong> 是一个标志符，设置后如果当前CPU的slab cache已经超出了 <strong>s-&gt;cpu_partial</strong> ，就会执行 <code>unfreeze_partials</code> 函数，将当前CPU的slab cache中已有的partial slab全部解冻，然后将新增的slab中包含的partial对象的数量添加到统计信息。<br />
slab中包含的partial对象的数量计算方法为 <code>pobjects = page-&gt;objects - page-&gt;inuse</code> 。</p>

<h3 id="4-1-1-unfreeze-partials">4.1.1. <code>unfreeze_partials</code></h3>

<p><code>put_cpu_partial</code> 调用 <code>unfreeze_partial</code> 函数时，传入的参数为操作的slab cache和当前CPU的slab cache对象。</p>

<pre><code class="language-C">static void unfreeze_partials(struct kmem_cache *s,
        struct kmem_cache_cpu *c)
{
#ifdef CONFIG_SLUB_CPU_PARTIAL  /* x86默认开启 */
    struct kmem_cache_node *n = NULL, *n2 = NULL;
    /* discard_page中保存要释放的slab */
    struct page *page, *discard_page = NULL;
    while ((page = c-&gt;partial)) {
        struct page new;
        struct page old;

        /*
         配合while语句遍历当前CPU的slab cache中
         所有的partial slab */
        c-&gt;partial = page-&gt;next;
        /* 获取当前slab所属的kmem_cache_node */
        n2 = get_node(s, page_to_nid(page));
        if (n != n2) {
            if (n)
                spin_unlock(&amp;n-&gt;list_lock);

            n = n2;
            spin_lock(&amp;n-&gt;list_lock);
        }
        /* 将frozen从1设置为0 */
        do {
            old.freelist = page-&gt;freelist;
            old.counters = page-&gt;counters;
            VM_BUG_ON(!old.frozen);

            new.counters = old.counters;
            new.freelist = old.freelist;

            new.frozen = 0;
        } while (!__cmpxchg_double_slab(s, page,
                old.freelist, old.counters,
                new.freelist, new.counters,
                &quot;unfreezing slab&quot;));
        /*
         !new.inuse为真表示slab为空
         如果slab空，并且节点中部分空slab的数量nr_partial不小于
         slab cache中指明的最小值min_partial，可以将当前的slab
         释放，先添加到discad_page中 */
        if (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial)) {
            page-&gt;next = discard_page;
            discard_page = page;
        } else {
            /* 添加到节点的partial list中 */
            add_partial(n, page, DEACTIVATE_TO_TAIL);
            stat(s, FREE_ADD_PARTIAL);
        }
    }

    if (n)
        spin_unlock(&amp;n-&gt;list_lock);

    /* 将所有可以释放的slab释放 */
    while (discard_page) {
        page = discard_page;
        discard_page = discard_page-&gt;next;
        stat(s, DEACTIVATE_EMPTY);
        discard_slab(s, page);
        stat(s, FREE_SLAB);
    }
#endif
}
</code></pre>

<h2 id="4-2-add-partial-remove-partial-remove-full">4.2. <code>add_partial</code> / <code>remove_partial</code> / <code>remove_full</code></h2>

<p>三个函数都是操作 <strong>struct page</strong> 的 <strong>struct list_head lru</strong> 成员，即从双向链表中直接删除slab项，并且设置 <code>lru-&gt;prev = LIST_POISON2</code> ， <code>lru-&gt;next = LIST_POISON1</code> 。</p>

<p>需要说明的是，在 <strong>struct page</strong> 中， <strong>lru</strong> 和 <strong>next</strong> ， <strong>pages</strong> ， <strong>pobjects</strong> 等成员位于一个union中：</p>

<pre><code class="language-C">struct page {
    ...
    union {
        struct list_head lru;
        struct {
            struct page *next;
            int pages;
            int pobjects;
        };
        ...
    };
    ...
}
</code></pre>

<p>也就是说，在执行删除操作时，赋值 <code>lru-&gt;next</code> 和 <code>lru-&gt;prev</code> 会使 <strong>struct page *next</strong> 指向 <strong>LIST_POISON1</strong> ，其他地方比如 <code>unfreeze_partials</code> 函数通过 <strong>next</strong> 遍历partial表，不会访问已经删除的slab。</p>

<h2 id="4-3-discard-slab">4.3. <code>discard_slab</code></h2>

<p><code>remove_partial</code> ， <code>remove_full</code> 只是将slab从表中删除，而 <code>discard_slab</code> 则将slab从slab cache中删除。</p>

<p><code>discard_slab</code> 首先调用 <code>dec_slabs_node</code> 将要删除的slab包含对象的数量从slab cache中删除，并且减少节点的 <strong>nr_slabs</strong> ，然后调用 <code>free_slab</code> 函数。</p>

<p><code>free_slab</code> 根据slab cache的标志执行不同的分支，这里介绍 <code>__free_slab</code> 分支。</p>

<pre><code class="language-C">static void __free_slab(struct kmem_cache *s, struct page *page)
{
    /* 获取页面的order */
    int order = compound_order(page);
    int pages = 1 &lt;&lt; order;

    ...

    kmemcheck_free_shadow(page, compound_order(page));
    /* 修改zone-&gt;vm_stat和全局统计变量vm_stat */
    mod_zone_page_state(page_zone(page),
        (s-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT) ?
        NR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE,
        -pages);
    /* 清除page的标志位 */
    __ClearPageSlabPfmemalloc(page);
    __ClearPageSlab(page);
    /* 设置page-&gt;_mapcount = -1 */
    page_mapcount_reset(page);
    if (current-&gt;reclaim_state)
        current-&gt;reclaim_state-&gt;reclaimed_slab += pages;
    /* 通过伙伴系统释放页面 */
    __free_pages(page, order);
    /* 从memcg系统删除 */
    memcg_uncharge_slab(s, order);
}
</code></pre>

<p>其中，清除标志位的函数都通过 <em>include/linux/page-flags.h</em> 中的宏定义，包括以双下划线开头的和不以双下划线开头的，后者是原子的，前者不是原子的。</p>

<pre><code class="language-C">#define SETPAGEFLAG(uname, lname)                   \
static inline void SetPage##uname(struct page *page)            \
            { set_bit(PG_##lname, &amp;page-&gt;flags); }

#define CLEARPAGEFLAG(uname, lname)                 \
static inline void ClearPage##uname(struct page *page)          \
            { clear_bit(PG_##lname, &amp;page-&gt;flags); }

#define __SETPAGEFLAG(uname, lname)                 \
static inline void __SetPage##uname(struct page *page)          \
            { __set_bit(PG_##lname, &amp;page-&gt;flags); }

#define __CLEARPAGEFLAG(uname, lname)                   \
static inline void __ClearPage##uname(struct page *page)        \
            { __clear_bit(PG_##lname, &amp;page-&gt;flags); }
</code></pre>

<h1 id="5-deactivate-slab">5. deactivate_slab</h1>

<p>虽然释放slab对象的过程中没有调用 <code>deactivate_slab</code> 函数，但是在slab分配对象的慢路径 <code>__slab_alloc</code> 执行的过程中，如果CPU正在使用的slab不属于当前的节点，或者slab设置了pfmemalloc标志，但是请求对象时没有设置ALLOC_NO_WATERMARK，就会将slab移除，放到节点的partial list中</p>

<p><code>deactivate_slab</code> 函数只有两个函数调用，一个是分配slab对象的慢路径，即 <code>__slab_alloc</code> ；另一个是 <code>flush_slab</code> 函数。<br />
而且，从代码来看，前一种情况的可能性较小，更多的情况是通过后一种路径调用函数，因此默认将移除的slab放到表头。</p>

<p>此处说明 <code>deactivate_slab</code> 时，假定通过 <code>__slab_alloc</code> 函数调用，即 <code>deactivate_slab(s, page, c-&gt;freelist)</code> ，则 <strong>page</strong> 为当前CPU正在使用的slab， <strong>freelist</strong> 不为空， <strong>page</strong> 可能位于当前的节点。</p>

<pre><code class="language-C">static void deactivate_slab(struct kmem_cache *s, struct page *page,
                void *freelist)
{
    enum slab_modes { M_NONE, M_PARTIAL, M_FULL, M_FREE };
    /* n指向要移除的slab所属的内存节点 */
    struct kmem_cache_node *n = get_node(s, page_to_nid(page));
    int lock = 0;
    enum slab_modes l = M_NONE, m = M_NONE;
    void *nextfree;
    /*
     默认情况下，移除的slab放到表头，因为是通过flush_slab
     调用，放到表头之后可在短时间内再次使用 */
    int tail = DEACTIVATE_TO_HEAD;
    struct page new;
    struct page old;

    /*
     如果page-&gt;freelist不等于空，说明其他CPU曾经释放对象
     到当前要移除的slab中，将其放到表尾 */
    if (page-&gt;freelist) {
        stat(s, DEACTIVATE_REMOTE_FREES);
        tail = DEACTIVATE_TO_TAIL;
    }
    /*
     如果freelist不为空，并且要移除的slab中有其他CPU释放的
     可用对象，则移除这些对象，将freelist指向slab最后一个
     可用的对象 */
    while (freelist &amp;&amp; (nextfree = get_freepointer(s, freelist))) {
        void *prior;
        unsigned long counters;

        do {
            prior = page-&gt;freelist;
            counters = page-&gt;counters;
            /* 将freelist指向page-&gt;freelist */
            set_freepointer(s, freelist, prior);
            new.counters = counters;
            new.inuse--;
            VM_BUG_ON(!new.frozen);

        } while (!__cmpxchg_double_slab(s, page,
            prior, counters,
            freelist, new.counters,
            &quot;drain percpu freelist&quot;));

        freelist = nextfree;
    }
redo:

    old.freelist = page-&gt;freelist;
    old.counters = page-&gt;counters;
    VM_BUG_ON(!old.frozen);

    /* Determine target state of the slab */
    new.counters = old.counters;
    /* 此时freelist指向移除的slab的最后一个可用对象 */
    if (freelist) {
        new.inuse--;
        /*
         将freelist指向page-&gt;freelist，即slab中
         最后一个空闲对象 */
        set_freepointer(s, freelist, old.freelist);
        new.freelist = freelist;
    } else
        /* new.freelist = old.freelist = page-&gt;freelist */
        new.freelist = old.freelist;
    /* 解冻 */
    new.frozen = 0;

    /*
     slab为空，并且节点的partial slab数量大于最小值，
     可以释放要移除的slab，设置为M_FREE状态 */
    if (!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial)
        m = M_FREE;
    /* slab的freelist有可用对象，应该放到partial表 */
    else if (new.freelist) {
        m = M_PARTIAL;
        if (!lock) {
            lock = 1;
            spin_lock(&amp;n-&gt;list_lock);
        }
    /* 否则是M_FULL */
    } else {
        m = M_FULL;
        if (kmem_cache_debug(s) &amp;&amp; !lock) {
            lock = 1;
            spin_lock(&amp;n-&gt;list_lock);
        }
    }

    if (l != m) {
        if (l == M_PARTIAL)

            remove_partial(n, page);

        else if (l == M_FULL)

            remove_full(s, n, page);

        if (m == M_PARTIAL) {

            add_partial(n, page, tail);
            stat(s, tail);

        } else if (m == M_FULL) {

            stat(s, DEACTIVATE_FULL);
            add_full(s, n, page);

        }
    }

    l = m;
    /*
     如果修改page的freelist失败，回到redo重新执行。
     这时需要根据l的状态先把之前添加到节点的slab移除，
     然后再插入，以保证一致性 */
    if (!__cmpxchg_double_slab(s, page,
                old.freelist, old.counters,
                new.freelist, new.counters,
                &quot;unfreezing slab&quot;))
        goto redo;

    if (lock)
        spin_unlock(&amp;n-&gt;list_lock);

    if (m == M_FREE) {
        stat(s, DEACTIVATE_EMPTY);
        discard_slab(s, page);
        stat(s, FREE_SLAB);
    }
}
</code></pre>

<h1 id="6-总结">6. 总结</h1>

<p>每个 <strong>struct kmem_cache</strong> 包含所有内存节点的partial slab信息，每个节点都有一个 <strong>struct list_head partial</strong> ，保存当前节点的所有partial slab；还有 <strong>unsigned long nr_partials</strong> 保存本节点partial slab的总数。</p>

<p><strong>struct kmem_cache</strong> 包含所有CPU的slab信息，每个CPU只有一个正在分配对象的slab，即 <strong>struct page *page</strong> 成员，以及指向当前可用对象的指针 <strong>void **freelist</strong> 。<br />
同时还有属于本CPU的partial slab列表 <strong>strut page *partial</strong> ，这些partial slab来自CPU的partial list，CPU会冻结属于自己的partial slab——别的CPU只能释放对象，不能执行其他操作。</p>

<p>创建一个新的slab时， <strong>struct page</strong> 的成员 <strong>freelist</strong> 会被置空，只通过CPU的 <strong>freelist</strong> 分配空闲对象。释放对象时也只操作CPU的 <strong>freelist</strong>。<br />
如果其他CPU释放不属于本CPU的slab的对象，直接操作 <strong>struct page</strong> 的 <strong>freelist</strong> ，这样在移除slab时，可以根据这个信息判断是否有异地释放对象的操作。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Globs Guo</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2019-10-21
        
    </span>
  </p>
  
  
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/wechat.jpg">
        <span>wechat</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/alipay.jpg">
        <span>alipay</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kernel-sources/">kernel-sources</a>
          <a href="/tags/memory/">memory</a>
          <a href="/tags/kmem_cache/">kmem_cache</a>
          <a href="/tags/slub/">slub</a>
          <a href="/tags/kmalloc_caches/">kmalloc_caches</a>
          <a href="/tags/kmalloc/">kmalloc</a>
          <a href="/tags/kfree/">kfree</a>
          <a href="/tags/slab_free/">slab_free</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/mm-slab_objects_allocation/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">mm-slab对象的分配</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/control_group/">
            <span class="next-text nav-default">control group</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="GlobsGuo/utterancesRepo"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="sendtomedivh@126.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/globsguo" class="iconfont icon-github" title="github"></a>
  <a href="https://globsguo.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Globs Guo</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
