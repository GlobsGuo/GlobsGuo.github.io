<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>mm-slab对象的回收 - Globs&#39; Catchall</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Globs Guo" /><meta name="description" content="本文仍然以slab cache kmalloc_caches 为例，结合 kfree 函数的实现，说明slab对象的回收过程。 1. kfree 通过 kfree 函数释放 kmalloc 申请的内存时，对应的函数定义在 mm/slub.c 中。 1 2 3 4 5" />






<meta name="generator" content="Hugo 0.58.3 with theme even" />


<link rel="canonical" href="https://blog.globs.site/post/mm-slab_objects_free/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="mm-slab对象的回收" />
<meta property="og:description" content="本文仍然以slab cache kmalloc_caches 为例，结合 kfree 函数的实现，说明slab对象的回收过程。 1. kfree 通过 kfree 函数释放 kmalloc 申请的内存时，对应的函数定义在 mm/slub.c 中。 1 2 3 4 5" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.globs.site/post/mm-slab_objects_free/" />
<meta property="article:published_time" content="2019-10-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-10-21T00:00:00+00:00" />
<meta itemprop="name" content="mm-slab对象的回收">
<meta itemprop="description" content="本文仍然以slab cache kmalloc_caches 为例，结合 kfree 函数的实现，说明slab对象的回收过程。 1. kfree 通过 kfree 函数释放 kmalloc 申请的内存时，对应的函数定义在 mm/slub.c 中。 1 2 3 4 5">


<meta itemprop="datePublished" content="2019-10-21T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-10-21T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="6004">



<meta itemprop="keywords" content="kernel-sources,memory,kmem_cache,slub,kmalloc_caches,kmalloc,kfree,slab_free," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="mm-slab对象的回收"/>
<meta name="twitter:description" content="本文仍然以slab cache kmalloc_caches 为例，结合 kfree 函数的实现，说明slab对象的回收过程。 1. kfree 通过 kfree 函数释放 kmalloc 申请的内存时，对应的函数定义在 mm/slub.c 中。 1 2 3 4 5"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Globs&#39; Catchall</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Globs&#39; Catchall</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">mm-slab对象的回收</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-10-21 </span>
        
          <span class="more-meta"> 6004 words </span>
          <span class="more-meta"> 12 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#1-kfree">1. kfree</a></li>
<li><a href="#2-slab-free-mm-slub-c">2. slab_free( <em>mm/slub.c</em> )</a></li>
<li><a href="#3-slab-free-mm-slub-c">3. __slab_free( <em>mm/slub.c</em> )</a></li>
<li><a href="#4-slab的操作函数">4. slab的操作函数</a>
<ul>
<li><a href="#4-1-put-cpu-partial">4.1. <code>put_cpu_partial</code></a>
<ul>
<li><a href="#4-1-1-unfreeze-partials">4.1.1. <code>unfreeze_partials</code></a></li>
</ul></li>
<li><a href="#4-2-add-partial-remove-partial-remove-full">4.2. <code>add_partial</code> / <code>remove_partial</code> / <code>remove_full</code></a></li>
<li><a href="#4-3-discard-slab">4.3. <code>discard_slab</code></a></li>
</ul></li>
<li><a href="#5-deactivate-slab">5. deactivate_slab</a></li>
<li><a href="#6-总结">6. 总结</a></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<p>本文仍然以slab cache <strong>kmalloc_caches</strong> 为例，结合 <code>kfree</code> 函数的实现，说明slab对象的回收过程。</p>

<h1 id="1-kfree">1. kfree</h1>

<p>通过 <code>kfree</code> 函数释放 <code>kmalloc</code> 申请的内存时，对应的函数定义在 <em>mm/slub.c</em> 中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">kfree</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>

    <span class="n">trace_kfree</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="cm">/* 地址为空直接返回 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="cm">/* 通过内核虚拟地址获取对应的struct page * */</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="cm">/* slab分配器没有管理这个内存页 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
        <span class="n">kfree_hook</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="cm">/* 直接通过伙伴系统释放内存页 */</span>
        <span class="n">__free_kmem_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* struct page中包含内存页的slab信息，包括该内存页
</span><span class="cm">       所属的slab cache，*/</span>
    <span class="n">slab_free</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">slab_cache</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kfree</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="2-slab-free-mm-slub-c">2. slab_free( <em>mm/slub.c</em> )</h1>

<p>如果 <code>kfree</code> 的参数地址所在的页面属于slab分配器，通过 <code>slab_free</code> 函数释放。 <code>slab_free</code> 函数也有两个分支，快路径和慢路径。</p>

<p>如果 <code>kfree</code> 的对象属于当前的cpu slab，执行快路径；否则执行慢路径。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">slab_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
            <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">**</span><span class="n">object</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tid</span><span class="p">;</span>

    <span class="n">slab_free_hook</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

<span class="nl">redo</span><span class="p">:</span>
    <span class="cm">/*
</span><span class="cm">     * Determine the currently cpus per cpu slab.
</span><span class="cm">     * The cpu may change afterward. However that does not matter since
</span><span class="cm">     * data is retrieved via this pointer. If we are on the same cpu
</span><span class="cm">     * during the cmpxchg then the free will succedd.
</span><span class="cm">     */</span>
    <span class="n">preempt_disable</span><span class="p">();</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>

    <span class="n">tid</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">;</span>
    <span class="n">preempt_enable</span><span class="p">();</span>
    <span class="cm">/*
</span><span class="cm">     释放的对象所在的内存页刚好是当前CPU正在使用的
</span><span class="cm">     slab，执行快路径，只需要添加到freelist中 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/*
</span><span class="cm">         设置要释放的对象指向当前的空闲对象，即把释放的对象
</span><span class="cm">         添加到CPU的freelist中 */</span>
        <span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">);</span>
        <span class="cm">/*
</span><span class="cm">         更新slab cache的cpu_slab变量，指向
</span><span class="cm">         最新的freelist，并且更新tid */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">this_cpu_cmpxchg_double</span><span class="p">(</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">,</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span>
                <span class="n">object</span><span class="p">,</span> <span class="n">next_tid</span><span class="p">(</span><span class="n">tid</span><span class="p">))))</span> <span class="p">{</span>

            <span class="n">note_cmpxchg_failure</span><span class="p">(</span><span class="s">&#34;slab_free&#34;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_FASTPATH</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span>
        <span class="cm">/*
</span><span class="cm">         page不是当前CPU正在分配对象的slab，执行慢路径。
</span><span class="cm">         可能是以下情况：
</span><span class="cm">         1. 释放的对象属于当前CPU的partial表
</span><span class="cm">         2. 释放的对象属于其他CPU的slab  */</span>
        <span class="n">__slab_free</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="3-slab-free-mm-slub-c">3. __slab_free( <em>mm/slub.c</em> )</h1>

<p>慢路径释放slab时，涉及到多个名称相近的变量，先对这些变量进行说明。</p>

<ul>
<li><p><strong>struct kmem_cache</strong> —— 描述一个slab cache：</p>

<ul>
<li><code>unsigned long min_partial</code><br />
node结点中部分空slab缓冲区数量不能小于这个值，如果小于这个值，空闲slab缓冲区则不能够进行释放，而是将空闲slab加入到node结点的部分空slab链表中。<br /></li>
<li><code>int cpu_partial</code><br />
同min_partial类似，只是这个值表示的是对象的数量，而不是部分空slab数量，即CPU的partial对象数量不能小于这个值，小于的情况下要去对应node结点的部分空链表中获取若干个部分空slab；否则在 <code>put_cpu_partial</code> 函数中进行解冻操作。</li>
</ul></li>

<li><p><strong>struct kmem_cache_cpu</strong> —— 描述一个CPU的slab cache：</p>

<ul>
<li><code>void **freelist</code><br />
指向下一个空闲的对象</li>
<li><code>struct page *partial</code><br />
CPU的部分空slab链表，放到CPU的部分空slab链表中的slab会被冻结，而放入node中的部分空slab链表则解冻，冻结标志在slab缓冲区描述符( <strong>struct page</strong> )中<br /></li>
<li><code>struct page *page</code><br />
当前分配对象的slab</li>
</ul></li>

<li><p><strong>struct kmem_cache_node</strong> —— 描述一个节点的slab cache：</p>

<ul>
<li><code>unsigned long nr_partial</code><br />
节点中部分空slab的数量</li>
<li><code>struct list_head partial</code><br />
保存部分空slab的链表</li>
</ul></li>

<li><p><strong>struct page</strong> —— 描述一个slab：</p>

<ul>
<li><code>void *freelist</code><br />
第一个空闲的对象</li>
<li><code>unsigned inuse:16</code><br />
slab中已经分配的对象的数量</li>
<li><code>unsigned frozen:1</code><br />
被冻结的slab不属于任何链表，不会进行列表的管理操作。<br />
只有冻结slab的CPU可以执行列表操作——其他的CPU可以往freelist中添加对象，但是只有冻结slab的CPU可以从freelist中获取对象。因此， <code>slab_free</code> 函数会跳过列表的相关操作。<br />
被冻结的slab主要用于特定目的，比如响应特定CPU的分配请求。<br />
<strong>frozen</strong> 标志用来判断某一个slab(即内存页)是否已经被某个CPU用作slab cache，即属于某个 <strong>kmem_cache_cpu</strong>。</li>
</ul></li>
</ul>

<p>和快路径 <code>slab_free</code> 不同，执行慢路径的原因是 <code>kfree</code> 释放的对象所属的内存页不是当前CPU正在分配对象的slab。<br />
因此，函数释放对象的时候修改的是 <strong>struct page</strong> 内的 <strong>freelist</strong> 指针，而不是CPU的freelist。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kt">void</span> <span class="nf">__slab_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prior</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">**</span><span class="n">object</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">was_frozen</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="n">new</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

    <span class="p">...</span>
    <span class="cm">/* do-while循环保证更改成功 */</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">prior</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
        <span class="n">counters</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
        <span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">prior</span><span class="p">);</span>
        <span class="cm">/*
</span><span class="cm">         counters的赋值操作会将和其位于相同union内的
</span><span class="cm">         inuse，objects，frozen字段赋值 */</span>
        <span class="n">new</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">counters</span><span class="p">;</span>
        <span class="n">was_frozen</span> <span class="o">=</span> <span class="n">new</span><span class="p">.</span><span class="n">frozen</span><span class="p">;</span>
        <span class="n">new</span><span class="p">.</span><span class="n">inuse</span><span class="o">--</span><span class="p">;</span>
        <span class="cm">/*
</span><span class="cm">         !new.inuse = true，slab中没有分配出去的对象，目前我
</span><span class="cm">         只想到了一种情况，即当前释放的对象是slab中的最后一个
</span><span class="cm">         对象，释放之后slab为空。
</span><span class="cm">         !prior = true，slab中没有可用的对象，即slab为满。
</span><span class="cm">         !was_frozen = true，slab没有被冻结，即不属于某一个CPU
</span><span class="cm">         的slab cache  */</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">||</span> <span class="o">!</span><span class="n">prior</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">was_frozen</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/*
</span><span class="cm">             slab为满，释放当前对象后会变成partial，而且
</span><span class="cm">             不属于某一个CPU的slab cache，将其冻结，使其
</span><span class="cm">             属于当前CPU的slab cache */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_has_cpu_partial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">prior</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/*
</span><span class="cm">                 释放当前的对象后slab为空，先获取节点信息，
</span><span class="cm">                 并且获取修改slab list所需的锁，以便之后
</span><span class="cm">                 释放空slab */</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
                <span class="cm">/*
</span><span class="cm">                 只有当前slab为空时才需要获取锁，并且在执行
</span><span class="cm">                 释放操作后释放锁 */</span>
                <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cmpxchg_double_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
        <span class="n">prior</span><span class="p">,</span> <span class="n">counters</span><span class="p">,</span>
        <span class="n">object</span><span class="p">,</span> <span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
        <span class="s">&#34;__slab_free&#34;</span><span class="p">));</span>
    <span class="cm">/*
</span><span class="cm">     n为空的可能性较大，即当前释放的对象是slab中的最后一个对象
</span><span class="cm">     的可能性较小。其他的可能情况为：
</span><span class="cm">     1. slab已满，并且slab不属于某个CPU
</span><span class="cm">     2. slab已经属于某个CPU
</span><span class="cm">     3. 无论slab是否属于某个CPU，slab的freelist不为空，且inuse
</span><span class="cm">     字段不为0 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/*
</span><span class="cm">         刚刚执行的冻结操作，将内存页添加到当前CPU的slab
</span><span class="cm">         cache的partial表。
</span><span class="cm">         这里put_cpu_partial函数将新的slab添加到partial
</span><span class="cm">         表时，如果当前CPU中已有的partial对象大于slab
</span><span class="cm">         cache的cpu_partial值，就会将当前CPU中的所有的
</span><span class="cm">         partial slab解冻，并且在节点中的partial slab
</span><span class="cm">         的数量不小于slab cache的cpu_partial值的情况下，
</span><span class="cm">         释放解冻的slab；否则将解冻的slab添加到节点的
</span><span class="cm">         partial表中。 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">was_frozen</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">put_cpu_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CPU_PARTIAL_FREE</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/*
</span><span class="cm">         slab已经属于其他CPU的slab cache，当前的CPU不是冻结
</span><span class="cm">         slab的CPU，无法执行其他的操作；这种情况下也没有获取
</span><span class="cm">         锁的操作，因此也不需要释放  */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">was_frozen</span><span class="p">)</span>
            <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_FROZEN</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/*
</span><span class="cm">     释放当前对象后slab为空，并且节点的partial slab数量仍然
</span><span class="cm">     大于slab cache中的最小阈值，可以直接将slab释放 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">min_partial</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">slab_empty</span><span class="p">;</span>

    <span class="cm">/* slab从full变为partial */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kmem_cache_has_cpu_partial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">prior</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="n">remove_full</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
        <span class="n">add_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">DEACTIVATE_TO_TAIL</span><span class="p">);</span>
        <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_ADD_PARTIAL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>

<span class="nl">slab_empty</span><span class="p">:</span>
    <span class="cm">/* 当前释放的对象是slab中的最后一个对象 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">prior</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 当前slab有多个对象 */</span>
        <span class="n">remove_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
        <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_REMOVE_PARTIAL</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* 当前slab只有一个对象，导致位于full表 */</span>
        <span class="n">remove_full</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* 释放获取的锁 */</span>
    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_SLAB</span><span class="p">);</span>
    <span class="cm">/* 释放slab */</span>
    <span class="n">discard_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="4-slab的操作函数">4. slab的操作函数</h1>

<p><code>__slab_free</code> 函数调用了多个操作slab的函数，包括 <code>put_cpu_partial</code> ， <code>add_partial</code> ， <code>remove_partial</code> ， <code>remove_full</code> ， <code>discard_slab</code> 。</p>

<h2 id="4-1-put-cpu-partial">4.1. <code>put_cpu_partial</code></h2>

<p><code>__slab_free</code> 函数执行时，如果如果slab不属于任何CPU的slab cache，就会在释放对象后把slab添加到当前CPU的slab cache中，作为partial slab。</p>

<p><strong>struct kmem_cache</strong> 结构体的 <strong>struct kmem_cache_cpu __percpu *cpu_slab</strong> 成员，其 <strong>struct page *partial</strong> 包含CPU的所有partial slab。<br />
这些slab通过 <strong>struct page</strong> 的 <strong>struct page *next</strong> 成员链接；每个slab(page)包含partial链表中剩余partial slabs所有对象的数量，即 <strong>pobjects</strong> ，还包含剩余的partial slabs的数量，即 <strong>pages</strong> 。<br />
也就是说，每个CPU的slab cache包含的partial slab都保存在一个链表中，这个链表通过 <code>*next</code> 指针链接；链表中的第一个slab包含链表中对象的总数和slab的总数，第二个slab包含除了第一个slab外对象的总数和slab的总数。</p>

<p><code>put_cpu_partial</code> 函数的原型如下：<br />
<code>static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);</code> 。<br />
<strong>s</strong> 是当前正在操作的slab cache， <strong>page</strong> 是要添加到partial list的slab， <strong>drain</strong> 是一个标志符，设置后如果当前CPU的slab cache已经超出了 <strong>s-&gt;cpu_partial</strong> ，就会执行 <code>unfreeze_partials</code> 函数，将当前CPU的slab cache中已有的partial slab全部解冻，然后将新增的slab中包含的partial对象的数量添加到统计信息。<br />
slab中包含的partial对象的数量计算方法为 <code>pobjects = page-&gt;objects - page-&gt;inuse</code> 。</p>

<h3 id="4-1-1-unfreeze-partials">4.1.1. <code>unfreeze_partials</code></h3>

<p><code>put_cpu_partial</code> 调用 <code>unfreeze_partial</code> 函数时，传入的参数为操作的slab cache和当前CPU的slab cache对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kt">void</span> <span class="nf">unfreeze_partials</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SLUB_CPU_PARTIAL  </span><span class="cm">/* x86默认开启 */</span><span class="cp">
</span><span class="cp"></span>    <span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">n2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="cm">/* discard_page中保存要释放的slab */</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">discard_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">page</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">page</span> <span class="n">new</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">page</span> <span class="n">old</span><span class="p">;</span>

        <span class="cm">/*
</span><span class="cm">         配合while语句遍历当前CPU的slab cache中
</span><span class="cm">         所有的partial slab */</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">partial</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="cm">/* 获取当前slab所属的kmem_cache_node */</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">n2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

            <span class="n">n</span> <span class="o">=</span> <span class="n">n2</span><span class="p">;</span>
            <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* 将frozen从1设置为0 */</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">old</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
            <span class="n">old</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
            <span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">old</span><span class="p">.</span><span class="n">frozen</span><span class="p">);</span>

            <span class="n">new</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">old</span><span class="p">.</span><span class="n">counters</span><span class="p">;</span>
            <span class="n">new</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">old</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>

            <span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">__cmpxchg_double_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
                <span class="n">old</span><span class="p">.</span><span class="n">freelist</span><span class="p">,</span> <span class="n">old</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
                <span class="n">new</span><span class="p">.</span><span class="n">freelist</span><span class="p">,</span> <span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
                <span class="s">&#34;unfreezing slab&#34;</span><span class="p">));</span>
        <span class="cm">/*
</span><span class="cm">         !new.inuse为真表示slab为空
</span><span class="cm">         如果slab空，并且节点中部分空slab的数量nr_partial不小于
</span><span class="cm">         slab cache中指明的最小值min_partial，可以将当前的slab
</span><span class="cm">         释放，先添加到discad_page中 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">min_partial</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">discard_page</span><span class="p">;</span>
            <span class="n">discard_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* 添加到节点的partial list中 */</span>
            <span class="n">add_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">DEACTIVATE_TO_TAIL</span><span class="p">);</span>
            <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_ADD_PARTIAL</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

    <span class="cm">/* 将所有可以释放的slab释放 */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">discard_page</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">discard_page</span><span class="p">;</span>
        <span class="n">discard_page</span> <span class="o">=</span> <span class="n">discard_page</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DEACTIVATE_EMPTY</span><span class="p">);</span>
        <span class="n">discard_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
        <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_SLAB</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#endif
</span><span class="cp"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="4-2-add-partial-remove-partial-remove-full">4.2. <code>add_partial</code> / <code>remove_partial</code> / <code>remove_full</code></h2>

<p>三个函数都是操作 <strong>struct page</strong> 的 <strong>struct list_head lru</strong> 成员，即从双向链表中直接删除slab项，并且设置 <code>lru-&gt;prev = LIST_POISON2</code> ， <code>lru-&gt;next = LIST_POISON1</code> 。</p>

<p>需要说明的是，在 <strong>struct page</strong> 中， <strong>lru</strong> 和 <strong>next</strong> ， <strong>pages</strong> ， <strong>pobjects</strong> 等成员位于一个union中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">page</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">lru</span><span class="p">;</span>
        <span class="k">struct</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">pages</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">pobjects</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="p">...</span>
    <span class="p">};</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>也就是说，在执行删除操作时，赋值 <code>lru-&gt;next</code> 和 <code>lru-&gt;prev</code> 会使 <strong>struct page *next</strong> 指向 <strong>LIST_POISON1</strong> ，其他地方比如 <code>unfreeze_partials</code> 函数通过 <strong>next</strong> 遍历partial表，不会访问已经删除的slab。</p>

<h2 id="4-3-discard-slab">4.3. <code>discard_slab</code></h2>

<p><code>remove_partial</code> ， <code>remove_full</code> 只是将slab从表中删除，而 <code>discard_slab</code> 则将slab从slab cache中删除。</p>

<p><code>discard_slab</code> 首先调用 <code>dec_slabs_node</code> 将要删除的slab包含对象的数量从slab cache中删除，并且减少节点的 <strong>nr_slabs</strong> ，然后调用 <code>free_slab</code> 函数。</p>

<p><code>free_slab</code> 根据slab cache的标志执行不同的分支，这里介绍 <code>__free_slab</code> 分支。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kt">void</span> <span class="nf">__free_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 获取页面的order */</span>
    <span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">pages</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>

    <span class="p">...</span>

    <span class="n">kmemcheck_free_shadow</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
    <span class="cm">/* 修改zone-&gt;vm_stat和全局统计变量vm_stat */</span>
    <span class="n">mod_zone_page_state</span><span class="p">(</span><span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
        <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">)</span> <span class="o">?</span>
        <span class="nl">NR_SLAB_RECLAIMABLE</span> <span class="p">:</span> <span class="n">NR_SLAB_UNRECLAIMABLE</span><span class="p">,</span>
        <span class="o">-</span><span class="n">pages</span><span class="p">);</span>
    <span class="cm">/* 清除page的标志位 */</span>
    <span class="n">__ClearPageSlabPfmemalloc</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="n">__ClearPageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="cm">/* 设置page-&gt;_mapcount = -1 */</span>
    <span class="n">page_mapcount_reset</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span><span class="p">)</span>
        <span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span><span class="o">-&gt;</span><span class="n">reclaimed_slab</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
    <span class="cm">/* 通过伙伴系统释放页面 */</span>
    <span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
    <span class="cm">/* 从memcg系统删除 */</span>
    <span class="n">memcg_uncharge_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>其中，清除标志位的函数都通过 <em>include/linux/page-flags.h</em> 中的宏定义，包括以双下划线开头的和不以双下划线开头的，后者是原子的，前者不是原子的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define SETPAGEFLAG(uname, lname)                   \
</span><span class="cp">static inline void SetPage##uname(struct page *page)            \
</span><span class="cp">            { set_bit(PG_##lname, &amp;page-&gt;flags); }
</span><span class="cp"></span>
<span class="cp">#define CLEARPAGEFLAG(uname, lname)                 \
</span><span class="cp">static inline void ClearPage##uname(struct page *page)          \
</span><span class="cp">            { clear_bit(PG_##lname, &amp;page-&gt;flags); }
</span><span class="cp"></span>
<span class="cp">#define __SETPAGEFLAG(uname, lname)                 \
</span><span class="cp">static inline void __SetPage##uname(struct page *page)          \
</span><span class="cp">            { __set_bit(PG_##lname, &amp;page-&gt;flags); }
</span><span class="cp"></span>
<span class="cp">#define __CLEARPAGEFLAG(uname, lname)                   \
</span><span class="cp">static inline void __ClearPage##uname(struct page *page)        \
</span><span class="cp">            { __clear_bit(PG_##lname, &amp;page-&gt;flags); }</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="5-deactivate-slab">5. deactivate_slab</h1>

<p>虽然释放slab对象的过程中没有调用 <code>deactivate_slab</code> 函数，但是在slab分配对象的慢路径 <code>__slab_alloc</code> 执行的过程中，如果CPU正在使用的slab不属于当前的节点，或者slab设置了pfmemalloc标志，但是请求对象时没有设置ALLOC_NO_WATERMARK，就会将slab移除，放到节点的partial list中</p>

<p><code>deactivate_slab</code> 函数只有两个函数调用，一个是分配slab对象的慢路径，即 <code>__slab_alloc</code> ；另一个是 <code>flush_slab</code> 函数。<br />
而且，从代码来看，前一种情况的可能性较小，更多的情况是通过后一种路径调用函数，因此默认将移除的slab放到表头。</p>

<p>此处说明 <code>deactivate_slab</code> 时，假定通过 <code>__slab_alloc</code> 函数调用，即 <code>deactivate_slab(s, page, c-&gt;freelist)</code> ，则 <strong>page</strong> 为当前CPU正在使用的slab， <strong>freelist</strong> 不为空， <strong>page</strong> 可能位于当前的节点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kt">void</span> <span class="nf">deactivate_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
                <span class="kt">void</span> <span class="o">*</span><span class="n">freelist</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="n">slab_modes</span> <span class="p">{</span> <span class="n">M_NONE</span><span class="p">,</span> <span class="n">M_PARTIAL</span><span class="p">,</span> <span class="n">M_FULL</span><span class="p">,</span> <span class="n">M_FREE</span> <span class="p">};</span>
    <span class="cm">/* n指向要移除的slab所属的内存节点 */</span>
    <span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">enum</span> <span class="n">slab_modes</span> <span class="n">l</span> <span class="o">=</span> <span class="n">M_NONE</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">M_NONE</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">nextfree</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     默认情况下，移除的slab放到表头，因为是通过flush_slab
</span><span class="cm">     调用，放到表头之后可在短时间内再次使用 */</span>
    <span class="kt">int</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">DEACTIVATE_TO_HEAD</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="n">new</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="n">old</span><span class="p">;</span>

    <span class="cm">/*
</span><span class="cm">     如果page-&gt;freelist不等于空，说明其他CPU曾经释放对象
</span><span class="cm">     到当前要移除的slab中，将其放到表尾 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DEACTIVATE_REMOTE_FREES</span><span class="p">);</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">DEACTIVATE_TO_TAIL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/*
</span><span class="cm">     如果freelist不为空，并且要移除的slab中有其他CPU释放的
</span><span class="cm">     可用对象，则移除这些对象，将freelist指向slab最后一个
</span><span class="cm">     可用的对象 */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">freelist</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nextfree</span> <span class="o">=</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">freelist</span><span class="p">)))</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">prior</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="n">prior</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
            <span class="n">counters</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
            <span class="cm">/* 将freelist指向page-&gt;freelist */</span>
            <span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">freelist</span><span class="p">,</span> <span class="n">prior</span><span class="p">);</span>
            <span class="n">new</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">counters</span><span class="p">;</span>
            <span class="n">new</span><span class="p">.</span><span class="n">inuse</span><span class="o">--</span><span class="p">;</span>
            <span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">frozen</span><span class="p">);</span>

        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">__cmpxchg_double_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
            <span class="n">prior</span><span class="p">,</span> <span class="n">counters</span><span class="p">,</span>
            <span class="n">freelist</span><span class="p">,</span> <span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
            <span class="s">&#34;drain percpu freelist&#34;</span><span class="p">));</span>

        <span class="n">freelist</span> <span class="o">=</span> <span class="n">nextfree</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">redo</span><span class="p">:</span>

    <span class="n">old</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
    <span class="n">old</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
    <span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">old</span><span class="p">.</span><span class="n">frozen</span><span class="p">);</span>

    <span class="cm">/* Determine target state of the slab */</span>
    <span class="n">new</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">old</span><span class="p">.</span><span class="n">counters</span><span class="p">;</span>
    <span class="cm">/* 此时freelist指向移除的slab的最后一个可用对象 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">freelist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">new</span><span class="p">.</span><span class="n">inuse</span><span class="o">--</span><span class="p">;</span>
        <span class="cm">/*
</span><span class="cm">         将freelist指向page-&gt;freelist，即slab中
</span><span class="cm">         最后一个空闲对象 */</span>
        <span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">freelist</span><span class="p">,</span> <span class="n">old</span><span class="p">.</span><span class="n">freelist</span><span class="p">);</span>
        <span class="n">new</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">freelist</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>
        <span class="cm">/* new.freelist = old.freelist = page-&gt;freelist */</span>
        <span class="n">new</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">old</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
    <span class="cm">/* 解冻 */</span>
    <span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*
</span><span class="cm">     slab为空，并且节点的partial slab数量大于最小值，
</span><span class="cm">     可以释放要移除的slab，设置为M_FREE状态 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">min_partial</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">M_FREE</span><span class="p">;</span>
    <span class="cm">/* slab的freelist有可用对象，应该放到partial表 */</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">freelist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">M_PARTIAL</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="cm">/* 否则是M_FULL */</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">M_FULL</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">M_PARTIAL</span><span class="p">)</span>

            <span class="n">remove_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">M_FULL</span><span class="p">)</span>

            <span class="n">remove_full</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">M_PARTIAL</span><span class="p">)</span> <span class="p">{</span>

            <span class="n">add_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>
            <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>

        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">M_FULL</span><span class="p">)</span> <span class="p">{</span>

            <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DEACTIVATE_FULL</span><span class="p">);</span>
            <span class="n">add_full</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">l</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     如果修改page的freelist失败，回到redo重新执行。
</span><span class="cm">     这时需要根据l的状态先把之前添加到节点的slab移除，
</span><span class="cm">     然后再插入，以保证一致性 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__cmpxchg_double_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
                <span class="n">old</span><span class="p">.</span><span class="n">freelist</span><span class="p">,</span> <span class="n">old</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
                <span class="n">new</span><span class="p">.</span><span class="n">freelist</span><span class="p">,</span> <span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
                <span class="s">&#34;unfreezing slab&#34;</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">M_FREE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DEACTIVATE_EMPTY</span><span class="p">);</span>
        <span class="n">discard_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
        <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_SLAB</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="6-总结">6. 总结</h1>

<p>每个 <strong>struct kmem_cache</strong> 包含所有内存节点的partial slab信息，每个节点都有一个 <strong>struct list_head partial</strong> ，保存当前节点的所有partial slab；还有 <strong>unsigned long nr_partials</strong> 保存本节点partial slab的总数。</p>

<p><strong>struct kmem_cache</strong> 包含所有CPU的slab信息，每个CPU只有一个正在分配对象的slab，即 <strong>struct page *page</strong> 成员，以及指向当前可用对象的指针 <strong>void **freelist</strong> 。<br />
同时还有属于本CPU的partial slab列表 <strong>strut page *partial</strong> ，这些partial slab来自CPU的partial list，CPU会冻结属于自己的partial slab——别的CPU只能释放对象，不能执行其他操作。</p>

<p>创建一个新的slab时， <strong>struct page</strong> 的成员 <strong>freelist</strong> 会被置空，只通过CPU的 <strong>freelist</strong> 分配空闲对象。释放对象时也只操作CPU的 <strong>freelist</strong>。<br />
如果其他CPU释放不属于本CPU的slab的对象，直接操作 <strong>struct page</strong> 的 <strong>freelist</strong> ，这样在移除slab时，可以根据这个信息判断是否有异地释放对象的操作。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Globs Guo</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2019-10-21
        
    </span>
  </p>
  
  
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/wechat.jpg">
        <span>wechat</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/alipay.jpg">
        <span>alipay</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kernel-sources/">kernel-sources</a>
          <a href="/tags/memory/">memory</a>
          <a href="/tags/kmem_cache/">kmem_cache</a>
          <a href="/tags/slub/">slub</a>
          <a href="/tags/kmalloc_caches/">kmalloc_caches</a>
          <a href="/tags/kmalloc/">kmalloc</a>
          <a href="/tags/kfree/">kfree</a>
          <a href="/tags/slab_free/">slab_free</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/mm-slab_objects_allocation/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">mm-slab对象的分配</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/control_group/">
            <span class="next-text nav-default">control group</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="GlobsGuo/utterancesRepo"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="sendtomedivh@126.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/globsguo" class="iconfont icon-github" title="github"></a>
  <a href="https://blog.globs.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2019 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Globs Guo</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
