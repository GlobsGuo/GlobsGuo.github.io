<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>mm-buddy_allocator分配页框(上) - Globs&#39; Catchall</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Globs Guo" /><meta name="description" content="slab系统调用buddy分配器分配所需要的内存页，作为slab使用。 和slab系统不同，buddy系统主要响应较大(至少为一个内存页)的内" />






<meta name="generator" content="Hugo 0.76.3 with theme even" />


<link rel="canonical" href="https://blog.globs.site/post/mm-buddy_allocator_page_allocation-1/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="mm-buddy_allocator分配页框(上)" />
<meta property="og:description" content="slab系统调用buddy分配器分配所需要的内存页，作为slab使用。 和slab系统不同，buddy系统主要响应较大(至少为一个内存页)的内" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.globs.site/post/mm-buddy_allocator_page_allocation-1/" />
<meta property="article:published_time" content="2019-10-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-10-24T00:00:00+00:00" />
<meta itemprop="name" content="mm-buddy_allocator分配页框(上)">
<meta itemprop="description" content="slab系统调用buddy分配器分配所需要的内存页，作为slab使用。 和slab系统不同，buddy系统主要响应较大(至少为一个内存页)的内">
<meta itemprop="datePublished" content="2019-10-24T00:00:00+00:00" />
<meta itemprop="dateModified" content="2019-10-24T00:00:00+00:00" />
<meta itemprop="wordCount" content="7344">



<meta itemprop="keywords" content="kernel-sources,memory,buddy-allocator,kmalloc,expand,get_page_from_freelist,__alloc_pages_nodemask,zlcache," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="mm-buddy_allocator分配页框(上)"/>
<meta name="twitter:description" content="slab系统调用buddy分配器分配所需要的内存页，作为slab使用。 和slab系统不同，buddy系统主要响应较大(至少为一个内存页)的内"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Globs&#39; Catchall</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Globs&#39; Catchall</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">mm-buddy_allocator分配页框(上)</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-10-24 </span>
        
          <span class="more-meta"> 7344 words </span>
          <span class="more-meta"> 15 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#11-alloc_kmem_pages">1.1. alloc_kmem_pages</a></li>
    <li><a href="#12-alloc_pages_current">1.2. alloc_pages_current</a></li>
  </ul>

  <ul>
    <li><a href="#31-cpuset_zone_allowed_softwall">3.1. cpuset_zone_allowed_softwall</a></li>
    <li><a href="#32-zone_watermark_ok">3.2. zone_watermark_ok</a></li>
    <li><a href="#33-buffered_rmqueue">3.3. buffered_rmqueue</a>
      <ul>
        <li><a href="#331-rmqueue_bulk">3.3.1. rmqueue_bulk</a></li>
        <li><a href="#332-__rmqueue">3.3.2. __rmqueue</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>slab系统调用buddy分配器分配所需要的内存页，作为slab使用。</p>
<p>和slab系统不同，buddy系统主要响应较大(至少为一个内存页)的内存分配请求，本文仍然从 <code>kmalloc</code> 函数的实现入手，结合伙伴系统的核心函数 <code>__alloc_pages_nodemask</code> ，说明伙伴系统分配页框的过程。</p>
<p>由于伙伴系统分配页框的流程十分复杂，本文只介绍分配页框的第一次尝试，即 <code>__alloc_pages_nodemask</code> 函数第一次调用 <code>get_page_from_freelist</code> 的具体流程； <code>__alloc_pages_slowpath</code> 函数放在下一篇文章。</p>
<h1 id="1-kmalloc_large">1. kmalloc_large</h1>
<p><code>kmalloc</code> 函数执行时，如果请求的内存大小大于 <strong>KMALLOC_MAX_CACHE_SIZE</strong> ，就会调用 <code>kmalloc_large</code> 函数完成内存分配操作。</p>
<p><code>kmalloc_large</code> 函数先根据请求的内存的大小调用 <code>get_order</code> 函数得出请求的内存的大小对应内存页的数量 <strong>order</strong> ，然后调用 <code>kmalloc_order</code> ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="o">*</span><span class="nf">kmalloc_order</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

    <span class="cm">/*
</span><span class="cm">     添加复合页面元数据标志，即释放内存时需要的信息。
</span><span class="cm">     复合页面的一个应用是实现transhugepage，即透明的
</span><span class="cm">     hugepage。
</span><span class="cm">     复合页面用连续的多个页面组成一个hugepage，其中的
</span><span class="cm">     第一个页面称作head page，其余的页面成为tail page。
</span><span class="cm">     head page中保存着hugepage的元数据。 */</span> 
	 
    <span class="n">flags</span> <span class="o">|=</span> <span class="n">__GFP_COMP</span><span class="p">;</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">alloc_kmem_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">page</span> <span class="o">?</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">kmemleak_alloc</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmalloc_order</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="11-alloc_kmem_pages">1.1. alloc_kmem_pages</h2>
<p>内核里这个函数的注释写道： <code>alloc_keme_pages</code> 会将新分配的页charge到kmem资源计数器。</p>
<p>这里的charge，即cgroup中的charge，结合charge字面的意思充电，可以理解为分配；对应的，uncharge可以理解为释放。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="cm">/*
</span><span class="cm"> * alloc_kmem_pages charges newly allocated pages to the kmem resource counter
</span><span class="cm"> * of the current memory cgroup.
</span><span class="cm"> *
</span><span class="cm"> * It should be used when the caller would like to use kmalloc, but since the
</span><span class="cm"> * allocation is large, it has to fall back to the page allocator.
</span><span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">alloc_kmem_pages</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* 判断memcg是否支持新的页面分配操作 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg_kmem_newpage_charge</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
    <span class="n">memcg_kmem_commit_charge</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="12-alloc_pages_current">1.2. alloc_pages_current</h2>
<p>NUMA系统中， <code>alloc_pages</code> 函数最终调用 <em>mm/mempolicy.c</em> 中的 <code>alloc_pages_current</code> 完成页面分配的操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">alloc_pages_current</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span> <span class="o">=</span> <span class="n">get_task_policy</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpuset_mems_cookie</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pol</span> <span class="o">||</span> <span class="n">in_interrupt</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">gfp</span> <span class="o">&amp;</span> <span class="n">__GFP_THISNODE</span><span class="p">))</span>
        <span class="n">pol</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_policy</span><span class="p">;</span>

<span class="nl">retry_cpuset</span><span class="p">:</span>
    <span class="n">cpuset_mems_cookie</span> <span class="o">=</span> <span class="n">read_mems_allowed_begin</span><span class="p">();</span>

    <span class="cm">/*
</span><span class="cm">     * No reference counting needed for current-&gt;mempolicy
</span><span class="cm">     * nor system default_policy
</span><span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_INTERLEAVE</span><span class="p">)</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page_interleave</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">interleave_nodes</span><span class="p">(</span><span class="n">pol</span><span class="p">));</span>
    <span class="k">else</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">__alloc_pages_nodemask</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
                <span class="n">policy_zonelist</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">numa_node_id</span><span class="p">()),</span>
                <span class="n">policy_nodemask</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">pol</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">read_mems_allowed_retry</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">)))</span>
        <span class="k">goto</span> <span class="n">retry_cpuset</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">alloc_pages_current</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>alloc_pages_current</code> 根据当前进程绑定的内存策略，执行不同的函数路径。</p>
<p>一种是 <strong>MPOL_INTERLEAVE</strong> ，执行 <code>alloc_page_interleave</code> ，首先获取可用的zonelist，最终通过 <code>__alloc_pages_nodemask</code> 分配内存页。<br>
否则直接调用 <code>__alloc_pages_nodemask</code> 函数分配内存页，第一种情况下 <strong>nodemask</strong> 参数为空。</p>
<h1 id="2-__alloc_pages_nodemask">2. __alloc_pages_nodemask</h1>
<p><code>__alloc_pages_nodemask</code> 函数即zoned buddy allocator，是伙伴系统的核心，执行内存页的分配操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">__alloc_pages_nodemask</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
            <span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 根据申请内存时提供的gfp标志获取zone类型 */</span>
    <span class="k">enum</span> <span class="n">zone_type</span> <span class="n">high_zoneidx</span> <span class="o">=</span> <span class="n">gfp_zone</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">preferred_zone</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">preferred_zoneref</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="cm">/* 根据gfp标志得到页面迁移的类型 */</span>
    <span class="kt">int</span> <span class="n">migratetype</span> <span class="o">=</span> <span class="n">allocflags_to_migratetype</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpuset_mems_cookie</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">alloc_flags</span> <span class="o">=</span> <span class="n">ALLOC_WMARK_LOW</span><span class="o">|</span><span class="n">ALLOC_CPUSET</span><span class="o">|</span><span class="n">ALLOC_FAIR</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">classzone_idx</span><span class="p">;</span>
    <span class="cm">/* 移除不支持的标志 */</span>
    <span class="n">gfp_mask</span> <span class="o">&amp;=</span> <span class="n">gfp_allowed_mask</span><span class="p">;</span>

    <span class="n">lockdep_trace_alloc</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>

    <span class="n">might_sleep_if</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">);</span>
    <span class="cm">/*
</span><span class="cm">     根据mm/page_alloc.c中的变量fail_page_alloc判断
</span><span class="cm">     当前的设置是否符合分配失败的情况 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">should_fail_alloc_page</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/*
</span><span class="cm">     初始化过后，zonelist-&gt;_zonerefs中包含所有可用的zone，
</span><span class="cm">     并且以NULL作为结束标志 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">zonelist</span><span class="o">-&gt;</span><span class="n">_zonerefs</span><span class="o">-&gt;</span><span class="n">zone</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">retry_cpuset</span><span class="p">:</span>
    <span class="n">cpuset_mems_cookie</span> <span class="o">=</span> <span class="n">read_mems_allowed_begin</span><span class="p">();</span>

    <span class="cm">/* The preferred zone is used for statistics later */</span>
    <span class="n">preferred_zoneref</span> <span class="o">=</span> <span class="n">first_zones_zonelist</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">high_zoneidx</span><span class="p">,</span>
                <span class="n">nodemask</span> <span class="o">?</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">cpuset_current_mems_allowed</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">preferred_zone</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">preferred_zone</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="n">classzone_idx</span> <span class="o">=</span> <span class="n">zonelist_zone_idx</span><span class="p">(</span><span class="n">preferred_zoneref</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CMA
</span><span class="cp"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">allocflags_to_migratetype</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">MIGRATE_MOVABLE</span><span class="p">)</span>
        <span class="n">alloc_flags</span> <span class="o">|=</span> <span class="n">ALLOC_CMA</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="cm">/* First allocation attempt */</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">get_page_from_freelist</span><span class="p">(</span><span class="n">gfp_mask</span><span class="o">|</span><span class="n">__GFP_HARDWALL</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
            <span class="n">zonelist</span><span class="p">,</span> <span class="n">high_zoneidx</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span>
            <span class="n">preferred_zone</span><span class="p">,</span> <span class="n">classzone_idx</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/*
</span><span class="cm">         * Runtime PM, block IO and its error handling path
</span><span class="cm">         * can deadlock because I/O on the device might not
</span><span class="cm">         * complete.
</span><span class="cm">         */</span>
        <span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">memalloc_noio_flags</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">__alloc_pages_slowpath</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
                <span class="n">zonelist</span><span class="p">,</span> <span class="n">high_zoneidx</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">,</span>
                <span class="n">preferred_zone</span><span class="p">,</span> <span class="n">classzone_idx</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">trace_mm_page_alloc</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>

<span class="nl">out</span><span class="p">:</span>
    <span class="cm">/*
</span><span class="cm">     * When updating a task&#39;s mems_allowed, it is possible to race with
</span><span class="cm">     * parallel threads in such a way that an allocation can fail while
</span><span class="cm">     * the mask is being updated. If a page allocation is about to fail,
</span><span class="cm">     * check if the cpuset changed during allocation and if so, retry.
</span><span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">read_mems_allowed_retry</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">)))</span>
        <span class="k">goto</span> <span class="n">retry_cpuset</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__alloc_pages_nodemask</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>__alloc_pages_nodemask</code> 通过 <code>first_zones_zonelist</code> 获取可以使用的第一个zoneref，成功后执行进一步操作—— <code>get_page_from_freelist</code> 。<br>
如果分配失败，移除可能存在的 <strong>PF_MEMALLOC_NOIO</strong> 标志，然后调用 <code>__alloc_pages_slowpath</code> 函数，再次尝试分配内存页。</p>
<h1 id="3-get_page_from_freelist">3. get_page_from_freelist</h1>
<p><code>get_page_from_freelist</code> 是 <code>__alloc_pages_nodemask</code> 分配页面的第一次尝试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="cm">/*
</span><span class="cm"> __alloc_pages_nodemask调用这个函数时，传入的参数
</span><span class="cm"> 只有gfp_mask发生了变化，增加了__GFP_HARDWALL标志，
</span><span class="cm"> 执行cpuset检查时会用到 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">get_page_from_freelist</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high_zoneidx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">preferred_zone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">classzone_idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
    <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">allowednodes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">zlc_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">did_zlc_setup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">consider_zone_dirty</span> <span class="o">=</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_WMARK_LOW</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WRITE</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">nr_fair_skipped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">zonelist_rescan</span><span class="p">;</span>

<span class="nl">zonelist_scan</span><span class="p">:</span>
    <span class="n">zonelist_rescan</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="cm">/* 扫描所有类型小于high_zoneidx的zone */</span>
    <span class="n">for_each_zone_zonelist_nodemask</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span>
                        <span class="n">high_zoneidx</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mark</span><span class="p">;</span>

        <span class="cm">/*
</span><span class="cm">         如果zlcache已经生效，只有bitmap中没有标记为满，
</span><span class="cm">         并且区域所属的节点包含在allowednodes中的zone
</span><span class="cm">         值得一试 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_NUMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">zlc_active</span> <span class="o">&amp;&amp;</span>
            <span class="o">!</span><span class="n">zlc_zone_worth_trying</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">allowednodes</span><span class="p">))</span>
                <span class="k">continue</span><span class="p">;</span>
        <span class="cm">/*
</span><span class="cm">         开启了cpuset功能，ALLOC_CPUSET指明分配操作要考虑
</span><span class="cm">         cpuset的限制，通过cpuset_zone_allowed_softwall
</span><span class="cm">         判断当前的zone能否用于分配操作 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cpusets_enabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_CPUSET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="o">!</span><span class="n">cpuset_zone_allowed_softwall</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">))</span>
                <span class="k">continue</span><span class="p">;</span>
        <span class="cm">/*
</span><span class="cm">         如果设置了ALLOC_FAIR，并且当前的zone和传入的
</span><span class="cm">         preferred_zone不属于相同的节点，直接从当前的
</span><span class="cm">         zone分配页面；否则增加由于fair被跳过的zone的
</span><span class="cm">         计数 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_FAIR</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zone_local</span><span class="p">(</span><span class="n">preferred_zone</span><span class="p">,</span> <span class="n">zone</span><span class="p">))</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">zone_is_fair_depleted</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">nr_fair_skipped</span><span class="o">++</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* dirty页筛选，保证每个zone的dirty页数量在限制内 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">consider_zone_dirty</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">zone_dirty_ok</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="n">mark</span> <span class="o">=</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">watermark</span><span class="p">[</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_WMARK_MASK</span><span class="p">];</span>
        <span class="cm">/*# watermark is not OK */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zone_watermark_ok</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">mark</span><span class="p">,</span>
                       <span class="n">classzone_idx</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">))</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

            <span class="cm">/* Checked here to keep the fast path fast */</span>
            <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">ALLOC_NO_WATERMARKS</span> <span class="o">&lt;</span> <span class="n">NR_WMARK</span><span class="p">);</span>
            <span class="cm">/*# don&#39;t care about watermark */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_NO_WATERMARKS</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">try_this_zone</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_NUMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                    <span class="o">!</span><span class="n">did_zlc_setup</span> <span class="o">&amp;&amp;</span> <span class="n">nr_online_nodes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/*
</span><span class="cm">                 建立zlcache，返回可用的节点。
</span><span class="cm">                 如果距离上一次zap位图达到1s，执行zap操作 */</span>
                <span class="n">allowednodes</span> <span class="o">=</span> <span class="n">zlc_setup</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">);</span>
                <span class="n">zlc_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">did_zlc_setup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="cm">/*
</span><span class="cm">             系统不允许zone回收，或者允许zone回收，但是当前
</span><span class="cm">             zone距离perferred_zone距离过大，标记为full */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">zone_reclaim_mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
                <span class="o">!</span><span class="n">zone_allows_reclaim</span><span class="p">(</span><span class="n">preferred_zone</span><span class="p">,</span> <span class="n">zone</span><span class="p">))</span>
                <span class="k">goto</span> <span class="n">this_zone_full</span><span class="p">;</span>

            <span class="cm">/*
</span><span class="cm">             * As we may have just activated ZLC, check if the first
</span><span class="cm">             * eligible zone has failed zone_reclaim recently.
</span><span class="cm">             */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_NUMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">zlc_active</span> <span class="o">&amp;&amp;</span>
                <span class="o">!</span><span class="n">zlc_zone_worth_trying</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">allowednodes</span><span class="p">))</span>
                <span class="k">continue</span><span class="p">;</span>

            <span class="cm">/* 获取可回收的页面数 */</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">zone_reclaim</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nl">ZONE_RECLAIM_NOSCAN</span><span class="p">:</span>
                <span class="cm">/* did not scan */</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">ZONE_RECLAIM_FULL</span><span class="p">:</span>
                <span class="cm">/* scanned but unreclaimable */</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="cm">/* did we reclaim enough */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">zone_watermark_ok</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">mark</span><span class="p">,</span>
                        <span class="n">classzone_idx</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">))</span>
                    <span class="k">goto</span> <span class="n">try_this_zone</span><span class="p">;</span>

                <span class="cm">/*
</span><span class="cm">                 * Failed to reclaim enough to meet watermark.
</span><span class="cm">                 * Only mark the zone full if checking the min
</span><span class="cm">                 * watermark or if we failed to reclaim just
</span><span class="cm">                 * 1&lt;&lt;order pages or else the page allocator
</span><span class="cm">                 * fastpath will prematurely mark zones full
</span><span class="cm">                 * when the watermark is between the low and
</span><span class="cm">                 * min watermarks.
</span><span class="cm">                 */</span>
                <span class="cm">/*
</span><span class="cm">                 如果已经使用的是最小的watermark，或者只能
</span><span class="cm">                 回收部分页面，但是仍然超过了watermark，在
</span><span class="cm">                 zlcache标记zone为full。
</span><span class="cm">                 这个标记动作只是在zlcache， */</span>
                <span class="k">if</span> <span class="p">(((</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_WMARK_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">ALLOC_WMARK_MIN</span><span class="p">)</span> <span class="o">||</span>
                    <span class="n">ret</span> <span class="o">==</span> <span class="n">ZONE_RECLAIM_SOME</span><span class="p">)</span>
                    <span class="k">goto</span> <span class="n">this_zone_full</span><span class="p">;</span>

                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

<span class="nl">try_this_zone</span><span class="p">:</span>
        <span class="cm">/*
</span><span class="cm">         wartermark高于限制值，或者设置了ALLOC_NO_WATERMARKS，
</span><span class="cm">         或者执行了回收操作后watermark高于限制值 */</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">buffered_rmqueue</span><span class="p">(</span><span class="n">preferred_zone</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
                        <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
<span class="nl">this_zone_full</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_NUMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">zlc_active</span><span class="p">)</span>
            <span class="n">zlc_mark_zone_full</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">page</span><span class="o">-&gt;</span><span class="n">pfmemalloc</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_NO_WATERMARKS</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">page</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_FAIR</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">alloc_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ALLOC_FAIR</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nr_fair_skipped</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">zonelist_rescan</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">reset_alloc_batches</span><span class="p">(</span><span class="n">preferred_zone</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nr_online_nodes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">zonelist_rescan</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_NUMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">zlc_active</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* Disable zlc cache for second zonelist scan */</span>
        <span class="n">zlc_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">zonelist_rescan</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">zonelist_rescan</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">zonelist_scan</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="31-cpuset_zone_allowed_softwall">3.1. cpuset_zone_allowed_softwall</h2>
<p>如果系统开启了cpuset功能， <code>cpuset_zone_allowed_softwall</code> 最终调用 <code>__cpuset_node_allowed_softwall</code> 实现cpuset的限制功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">int</span> <span class="nf">__cpuset_node_allowed_softwall</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">cpuset</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>      <span class="cm">/* current cpuset ancestors */</span>
    <span class="kt">int</span> <span class="n">allowed</span><span class="p">;</span>            <span class="cm">/* is allocation in zone z allowed? */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_THISNODE</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">might_sleep_if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_HARDWALL</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node_isset</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="cm">/*
</span><span class="cm">     * Allow tasks that have access to memory reserves because they have
</span><span class="cm">     * been OOM killed to get memory anywhere.
</span><span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_MEMDIE</span><span class="p">)))</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_HARDWALL</span><span class="p">)</span>  
        <span class="cm">/* If hardwall request, stop here */</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span> <span class="cm">/* Let dying task have memory */</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="cm">/* Not hardwall and node outside mems_allowed: scan up cpusets */</span>
    <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>

    <span class="n">rcu_read_lock</span><span class="p">();</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">nearest_hardwall_ancestor</span><span class="p">(</span><span class="n">task_cs</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
    <span class="n">allowed</span> <span class="o">=</span> <span class="n">node_isset</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mems_allowed</span><span class="p">);</span>
    <span class="n">rcu_read_unlock</span><span class="p">();</span>

    <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">allowed</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里直接引用代码中的注释对函数进行说明：</p>
<blockquote>
<p>If we&rsquo;re in interrupt, yes, we can always allocate.  If __GFP_THISNODE is set, yes, we can always allocate.  If node is in our task&rsquo;s mems_allowed, yes.  If it&rsquo;s not a __GFP_HARDWALL request and this node is in the nearest hardwalled cpuset ancestor to this task&rsquo;s cpuset, yes.  If the task has been OOM killed and has access to memory reserves as specified by the TIF_MEMDIE flag, yes.<br>
Otherwise, no.</p>
</blockquote>
<p>处于中断状态；设置了 <strong>__GFP_THISNODE</strong> ；节点包含在 <strong>mems_allowed</strong> ，三种情况下可以直接允许分配。<br>
如果不是 <strong>__GFP_HARDWALL</strong> 请求，但是节点位于当前进程的cpuset的祖先cpuset内，允许分配。<br>
如果进程由于OOM被杀死，允许分配。<br>
其他情况不允许分配。</p>
<blockquote>
<p>If __GFP_HARDWALL is set, cpuset_node_allowed_softwall() reduces to cpuset_node_allowed_hardwall().  Otherwise, cpuset_node_allowed_softwall() might sleep, and might allow a node from an enclosing cpuset.<br>
cpuset_node_allowed_hardwall() only handles the simpler case of hardwall cpusets, and never sleeps.</p>
</blockquote>
<p>设置 <strong>__GFP_HARDWALL</strong> 函数直接缩减为 <code>cpuset_node_allowed_hardwall</code> ；不设置的话， <code>cpuset_node_allowed_software</code> 可能休眠。</p>
<blockquote>
<p>The __GFP_THISNODE placement logic is really handled elsewhere, by forcibly using a zonelist starting at a specified node, and by (in get_page_from_freelist()) refusing to consider the zones for any node on the zonelist except the first.  By the time any such calls get to this routine, we should just shut up and say &lsquo;yes&rsquo;.</p>
</blockquote>
<p><strong>_GFP_THISNODE</strong> 标志在其他地方已经进行处理，因此直接返回允许。</p>
<blockquote>
<p>GFP_USER allocations are marked with the __GFP_HARDWALL bit, and do not allow allocations outside the current tasks cpuset unless the task has been OOM killed as is marked TIF_MEMDIE. GFP_KERNEL allocations are not so marked, so can escape to the nearest enclosing hardwalled ancestor cpuset.</p>
</blockquote>
<p><strong>GFP_USER</strong> 标志设置了 <strong>__GFP_HARDWALL</strong> ，不允许从当前进程的cpuset以外的zone分配内存，除非设置了 <strong>TIF_MEMDIE</strong> 标志。 <strong>GFP_KERNEL</strong> 没有这个标志，因此可以从最近的祖先cpuset分配内存。</p>
<blockquote>
<p>The first call here from mm/page_alloc:get_page_from_freelist() has __GFP_HARDWALL set in gfp_mask, enforcing hardwall cpusets, so no allocation on a node outside the cpuset is allowed (unless in interrupt, of course).</p>
</blockquote>
<p><em>mm/page_alloc.c</em> 中 <code>__alloc_pages_nodemask</code> 第一次调用 <code>get_page_from_freelist</code> 时，设置了 <strong>__GFP_HARDWALL</strong> 标志，不允许从cpuset外的节点分配内存(除非处于中断中)。</p>
<blockquote>
<p>The second pass through get_page_from_freelist() doesn&rsquo;t even call here for GFP_ATOMIC calls.  For those calls, the __alloc_pages() variable &lsquo;wait&rsquo; is not set, and the bit ALLOC_CPUSET is not set in alloc_flags.  That logic and the checks below have the combined affect that:</p>
<p>in_interrupt - any node ok (current task context irrelevant)<br>
GFP_ATOMIC   - any node ok<br>
TIF_MEMDIE   - any node ok<br>
GFP_KERNEL   - any node in enclosing hardwalled cpuset ok<br>
GFP_USER     - only nodes in current tasks mems allowed ok.</p>
</blockquote>
<p><code>__alloc_pages_nodemask</code> 执行慢路径 <code>__alloc_pages_slowpath</code> 时，还会调用 <code>get_page_from_freelist</code> 。如果设置了 <strong>GFP_ATOMIC</strong> ，不会执行这个函数。这些函数调用不会设置 <code>__alloc_pages</code> 的wait变量， <strong>alloc_flags</strong> 的 <strong>ALLOC_CPUSET</strong> 也不会设置。</p>
<h2 id="32-zone_watermark_ok">3.2. zone_watermark_ok</h2>
<p>对于列表中的每个zone，如果zlcache没有标记为满，并且位于可用的内存节点，符合cpuset的限制，并且没有设置 <strong>ALLOC_FAIR</strong> 分配标志，通过了dirty检查，则调用 <strong>zone_watermark_ok</strong> 函数判断当前zone的空闲页是否高于给定的watermark。</p>
<p><code>zone_watermark_ok</code> 函数通过 <code>__zone_watermark_ok</code> 函数实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">__zone_watermark_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">z</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mark</span><span class="p">,</span> <span class="kt">int</span> <span class="n">classzone_idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">,</span>
            <span class="kt">long</span> <span class="n">free_pages</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* free_pages my go negative - that&#39;s OK */</span>
    <span class="kt">long</span> <span class="n">min</span> <span class="o">=</span> <span class="n">mark</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">o</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">free_cma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">free_pages</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_HIGH</span><span class="p">)</span>
        <span class="n">min</span> <span class="o">-=</span> <span class="n">min</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_HARDER</span><span class="p">)</span>
        <span class="n">min</span> <span class="o">-=</span> <span class="n">min</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_CMA    </span><span class="c1">// x86默认未配置
</span><span class="c1"></span>    <span class="cm">/* If allocation can&#39;t use CMA areas don&#39;t use free CMA pages */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_CMA</span><span class="p">))</span>
        <span class="n">free_cma</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">NR_FREE_CMA_PAGES</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span>
    <span class="cm">/*
</span><span class="cm">     如果分配所需的页面后剩余的空闲页面的数量小于
</span><span class="cm">     watermark + 每个zone的保留页的数量，返回false */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">free_pages</span> <span class="o">-</span> <span class="n">free_cma</span> <span class="o">&lt;=</span> <span class="n">min</span> <span class="o">+</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">lowmem_reserve</span><span class="p">[</span><span class="n">classzone_idx</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">o</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">o</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">;</span> <span class="n">o</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* At the next order, this order&#39;s pages become unavailable */</span>
        <span class="n">free_pages</span> <span class="o">-=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">o</span><span class="p">].</span><span class="n">nr_free</span> <span class="o">&lt;&lt;</span> <span class="n">o</span><span class="p">;</span>

        <span class="cm">/* Require fewer higher order pages to be free */</span>
        <span class="n">min</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">free_pages</span> <span class="o">&lt;=</span> <span class="n">min</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="33-buffered_rmqueue">3.3. buffered_rmqueue</h2>
<p>如果找到了可以使用的zone，就通过 <code>buffered_rmqueue</code> 从zone中分配所需的内存页：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">buffered_rmqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">preferred_zone</span><span class="p">,</span>
            <span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
            <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">cold</span> <span class="o">=</span> <span class="p">((</span><span class="n">gfp_flags</span> <span class="o">&amp;</span> <span class="n">__GFP_COLD</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">again</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">per_cpu_pages</span> <span class="o">*</span><span class="n">pcp</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>

        <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
        <span class="n">pcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">pageset</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pcp</span><span class="p">;</span>
        <span class="cm">/* 获取当前CPU给定migratetype的page表 */</span>
        <span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcp</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="n">migratetype</span><span class="p">];</span>
        <span class="cm">/*
</span><span class="cm">         per-cpu页框高速缓存为空，调用rmqueue_bulk从
</span><span class="cm">         伙伴系统申请batch个内存页进行补充 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">pcp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="n">rmqueue_bulk</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">pcp</span><span class="o">-&gt;</span><span class="n">batch</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span>
                    <span class="n">migratetype</span><span class="p">,</span> <span class="n">cold</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">)))</span>
                <span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* 从list头部取hot page，从尾部取cold page */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cold</span><span class="p">)</span>
            <span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>

        <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
        <span class="n">pcp</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">gfp_flags</span> <span class="o">&amp;</span> <span class="n">__GFP_NOFAIL</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* 警告大于2个page的nofail申请 */</span>
            <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="cm">/* 多页请求通过伙伴系统申请 */</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">__rmqueue</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
        <span class="cm">/* 减少zone的空闲页面计数 */</span>
        <span class="n">__mod_zone_freepage_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">),</span>
                      <span class="n">get_freepage_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/* 减去zone的NR_ALLOC_BATCH计数 */</span>
    <span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ALLOC_BATCH</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">));</span>
    <span class="cm">/* 将NR_ALLOC_BATCH为0的zone也标记为fair depleted */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ALLOC_BATCH</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="n">zone_is_fair_depleted</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span>
        <span class="n">zone_set_flag</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">ZONE_FAIR_DEPLETED</span><span class="p">);</span>

    <span class="cm">/* 增加vm_event计数 */</span>
    <span class="n">__count_zone_vm_events</span><span class="p">(</span><span class="n">PGALLOC</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">);</span>
    <span class="n">zone_statistics</span><span class="p">(</span><span class="n">preferred_zone</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

    <span class="n">VM_BUG_ON_PAGE</span><span class="p">(</span><span class="n">bad_range</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">page</span><span class="p">),</span> <span class="n">page</span><span class="p">);</span>
    <span class="cm">/* 根据分配标志符初始化申请到的内存页，下列原因会
</span><span class="cm">     导致检查失败：
</span><span class="cm">     1. _mapcount != 0
</span><span class="cm">     2. mapping != NULL
</span><span class="cm">     3. _count != 0
</span><span class="cm">     4. 一些flag不为0
</span><span class="cm">     5. cgroup检查失败  */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">prep_new_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">page</span><span class="p">;</span>

<span class="nl">failed</span><span class="p">:</span>
    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="331-rmqueue_bulk">3.3.1. rmqueue_bulk</h3>
<p>作为补充per-cpu页框高速缓存的内存页的函数， <code>rmqueue_bulk</code> 通过 <code>__rmqueue</code> 依次从伙伴系统申请 <strong>batch</strong> 个页框，并根据传入的 <strong>cold</strong> 参数将申请到的页面依次添加到传入的 <strong>list</strong> (即per-cpu页框高速缓存的页框链表)的头部(cold为false)或者尾部(cold为true)。</p>
<p>函数会修改zone的空闲页面统计数，返回真正申请到的页面数。</p>
<h3 id="332-__rmqueue">3.3.2. __rmqueue</h3>
<p><code>__rmqueue</code> 是“真正”的伙伴系统分配函数，函数第一次尝试分配请求的migratetype所需的页面数；如果失败，并且第一次请求的migratetype不是 <strong>MIGRATE_RESERVE</strong> ，再调用 <code>__rmqueue_fallback</code> 尝试分配；如果分配再次失败，则将migratetype置为 <strong>MIGRATE_RESERVE</strong> ，从保留内存区域进行分配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">__rmqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
                        <span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

<span class="nl">retry_reserve</span><span class="p">:</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">__rmqueue_smallest</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">migratetype</span> <span class="o">!=</span> <span class="n">MIGRATE_RESERVE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">__rmqueue_fallback</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>

        <span class="cm">/*
</span><span class="cm">         * Use MIGRATE_RESERVE rather than fail an allocation. goto
</span><span class="cm">         * is used because __rmqueue_smallest is an inline function
</span><span class="cm">         * and we want just one call site
</span><span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">migratetype</span> <span class="o">=</span> <span class="n">MIGRATE_RESERVE</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">retry_reserve</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">trace_mm_page_alloc_zone_locked</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="3321-__rmqueue_smallest">3.3.2.1. __rmqueue_smallest</h4>
<p><code>__rmqueue_smallest</code> 是 <code>__rmqueue</code> 函数分配页框的第一次尝试。<br>
函数从传入的order开始，从zone中最接近order的 <strong>free_area</strong> 中分配页框。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">__rmqueue_smallest</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
                        <span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">current_order</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">free_area</span> <span class="o">*</span><span class="n">area</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

    <span class="cm">/* Find a page of the appropriate size in the preferred list */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">current_order</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span> <span class="n">current_order</span> <span class="o">&lt;</span> <span class="n">MAX_ORDER</span><span class="p">;</span> <span class="o">++</span><span class="n">current_order</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">area</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">current_order</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">[</span><span class="n">migratetype</span><span class="p">]))</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">[</span><span class="n">migratetype</span><span class="p">].</span><span class="n">next</span><span class="p">,</span>
                            <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
        <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
        <span class="n">rmv_page_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
        <span class="n">area</span><span class="o">-&gt;</span><span class="n">nr_free</span><span class="o">--</span><span class="p">;</span>
        <span class="n">expand</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">current_order</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
        <span class="n">set_freepage_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">page</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果没有和给定的order相同的 <strong>free_area</strong> ，<code>__rmqueue_smallest</code> 从最接近order的 <strong>free_area</strong> 分配内存，然后 调用<code>expand</code> 函数将原来order较大的内存块切分成较小的内存块，并且添加到相应的链表中。</p>
<h4 id="3322-__rmqueue_fallback">3.3.2.2. __rmqueue_fallback</h4>
<p>如果 <code>__rmqueue_smallest</code> 分配失败，并且migratetype不是reserve类型，则调用 <code>__rmqueue_fallback</code> 函数尝试分配。<br>
和 <code>__rmqueue_smallest</code> 不同， <code>__rmqueue_fallback</code> 从最大的order开始，从 <strong>fallback</strong> 表中，查找当前migratetype对应的可用migratetype，获取可用的 <strong>free_area</strong> ，然后从中分配页框。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">__rmqueue_fallback</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_migratetype</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">free_area</span> <span class="o">*</span><span class="n">area</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">current_order</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">migratetype</span><span class="p">,</span> <span class="n">new_type</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

    <span class="cm">/* Find the largest possible block of pages in the other list */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">current_order</span> <span class="o">=</span> <span class="n">MAX_ORDER</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="n">current_order</span> <span class="o">&gt;=</span> <span class="n">order</span> <span class="o">&amp;&amp;</span> <span class="n">current_order</span> <span class="o">&lt;=</span> <span class="n">MAX_ORDER</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="o">--</span><span class="n">current_order</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">migratetype</span> <span class="o">=</span> <span class="n">fallbacks</span><span class="p">[</span><span class="n">start_migratetype</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>

            <span class="cm">/* MIGRATE_RESERVE handled later if necessary */</span>
            <span class="cm">/* MIGRATE_RESERVE是最后一个元素 */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">migratetype</span> <span class="o">==</span> <span class="n">MIGRATE_RESERVE</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="n">area</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">current_order</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">[</span><span class="n">migratetype</span><span class="p">]))</span>
                <span class="k">continue</span><span class="p">;</span>

            <span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">[</span><span class="n">migratetype</span><span class="p">].</span><span class="n">next</span><span class="p">,</span>
                    <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
            <span class="n">area</span><span class="o">-&gt;</span><span class="n">nr_free</span><span class="o">--</span><span class="p">;</span>
            <span class="cm">/* start_migratetype是首选，migratetype是后备选项 */</span>
            <span class="n">new_type</span> <span class="o">=</span> <span class="n">try_to_steal_freepages</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
                              <span class="n">start_migratetype</span><span class="p">,</span>
                              <span class="n">migratetype</span><span class="p">);</span>

            <span class="cm">/* Remove the page from the freelists */</span>
            <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
            <span class="n">rmv_page_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

            <span class="cm">/*
</span><span class="cm">             expand函数将
</span><span class="cm">             free_area[current_order].freelist[new_type]
</span><span class="cm">             切分成较小order的内存块，保存到响应列表 */</span>
            <span class="n">expand</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">current_order</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span>
                   <span class="n">new_type</span><span class="p">);</span>
            <span class="cm">/* The freepage_migratetype may differ from pageblock&#39;s
</span><span class="cm">             * migratetype depending on the decisions in
</span><span class="cm">             * try_to_steal_freepages. This is OK as long as it does
</span><span class="cm">             * not differ for MIGRATE_CMA type.
</span><span class="cm">             */</span>
            <span class="n">set_freepage_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">new_type</span><span class="p">);</span>

            <span class="n">trace_mm_page_alloc_extfrag</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">current_order</span><span class="p">,</span>
                <span class="n">start_migratetype</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">,</span> <span class="n">new_type</span><span class="p">);</span>

            <span class="k">return</span> <span class="n">page</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>fallbacks</strong> 是定义在 <em>mm/page_alloc.c</em> 中的二维数组，保存着每种migratetype分配失败时，可以使用的其他migratetype。</p>
<p>如果 <code>__rmqueue_fallback</code> 也分配失败， <code>__rmqueue</code> 将migratetype设置成reserve类型，再次执行上面两个函数进行分配。</p>
<h5 id="33221-try_to_steal_freepages">3.3.2.2.1. try_to_steal_freepages</h5>
<p>找到可用的 <strong>free_area</strong> 之后， <code>__rmqueue_fallback</code> 调用 <code>try_to_steal_freepages</code> ，根据 <strong>fallback_type</strong> 移动空闲页框。</p>
<p>内核中函数的注释为：</p>
<blockquote>
<p>切分一个大块的内存时，将所有空闲页框移动到首选的分配列表。如果fallback_type是可回收的内核分配，更积极主动的获取空闲页面的所有权。</p>
<p>另一方面，不要改变 <strong>MIGRATE_CMA</strong> 内存块的migratetype，也不要将CMA的页框移动到其他的空闲列表中，我们不想从 <strong>MIGRATE_CMA</strong> 区域分配不可用的页框。</p>
</blockquote>
<p>函数中的 <strong>pageblock_order</strong> 变量定义在 <em>include/linux/pageblock-flags.h</em> ，如果开启了 <strong>CONFIG_HUGETLB_PAGE</strong> (默认开启)，并且没有通过内核配置提供order值，就采用 <strong>HUGETLB_PAGE_ORDER</strong> ，即9；否则为 <strong>MAX_ORDER-1</strong> ，即10。<br>
<strong>page_group_by_mobility_disabled</strong> 变量在 <code>build_all_zonelists</code> 设置，如果系统中页框数量太低，将其置为1，关闭“group by mobility”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="cm">/*
</span><span class="cm"> @start_type为首选的迁移类型，即请求内存时的类型
</span><span class="cm"> @fallback_type为备选的类型，即通过fallbacks获取的类型 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_to_steal_freepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="n">start_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fallback_type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* current_order为当前找到的内存块的阶数 */</span>
    <span class="kt">int</span> <span class="n">current_order</span> <span class="o">=</span> <span class="n">page_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

    <span class="cm">/*
</span><span class="cm">     * When borrowing from MIGRATE_CMA, we need to release the excess
</span><span class="cm">     * buddy pages to CMA itself. We also ensure the freepage_migratetype
</span><span class="cm">     * is set to CMA so it is returned to the correct freelist in case
</span><span class="cm">     * the page ends up being not actually allocated from the pcp lists.
</span><span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_migrate_cma</span><span class="p">(</span><span class="n">fallback_type</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">fallback_type</span><span class="p">;</span>

    <span class="cm">/* Take ownership for orders &gt;= pageblock_order */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current_order</span> <span class="o">&gt;=</span> <span class="n">pageblock_order</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*
</span><span class="cm">         change_pageblock_range将找到的内存块按照
</span><span class="cm">         pageblock_order的大小分割，都设置migratetype
</span><span class="cm">         为start_type，即首选的迁移类型 */</span>
        <span class="n">change_pageblock_range</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">current_order</span><span class="p">,</span> <span class="n">start_type</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">start_type</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
</span><span class="cm">     下列情况还会将页框移动到，即更积极的获取空闲页框的
</span><span class="cm">     所有权：
</span><span class="cm">     1. 当前order大于等于pageblock_order的一半
</span><span class="cm">     2. 首选为可回收的迁移类型
</span><span class="cm">     3. 关闭了“group by mobility” */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current_order</span> <span class="o">&gt;=</span> <span class="n">pageblock_order</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">||</span>
        <span class="n">start_type</span> <span class="o">==</span> <span class="n">MIGRATE_RECLAIMABLE</span> <span class="o">||</span>
        <span class="n">page_group_by_mobility_disabled</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pages</span><span class="p">;</span>

        <span class="cm">/* 将内存块移动到start_type的列表 */</span>
        <span class="n">pages</span> <span class="o">=</span> <span class="n">move_freepages_block</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">start_type</span><span class="p">);</span>

        <span class="cm">/* Claim the whole block if over half of it is free */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pages</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">pageblock_order</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">||</span>
                <span class="n">page_group_by_mobility_disabled</span><span class="p">)</span> <span class="p">{</span>

            <span class="cm">/*
</span><span class="cm">             move_freepages中设置migratetype的操作，可能没有
</span><span class="cm">             设置page的迁移类型——对齐到pageblock_nr_pages */</span>
            <span class="n">set_pageblock_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">start_type</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">start_type</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="n">fallback_type</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从代码可以看出，对于内存块阶数大于 <strong>pageblock_order</strong> 的情况，只是修改页框的migratetype，并没有真正移动空闲页；而“更积极的获取空闲页框的所有权”则意味着将空闲页框移动到指定的迁移类型的列表中。</p>
<h5 id="33222-move_freepages">3.3.2.2.2. move_freepages</h5>
<p><code>try_to_steal_freepages</code> 调用 <code>move_freepages_block</code> 移动空闲页框，后者先获取内存块的起止物理页框号对应的 <strong>struct page</strong> ，并进行合法性检查(这里有个疑问，不知道为什么将起止pfn对齐到pageblock_nr_pages)，然后调用 <code>move_freepages</code> 函数，移动页框到参数指定的迁移类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">int</span> <span class="nf">move_freepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span>
              <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">start_page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">end_page</span><span class="p">,</span>
              <span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">order</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pages_moved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_HOLES_IN_ZONE
</span><span class="cp"></span>    <span class="cm">/*
</span><span class="cm">     * page_zone is not safe to call in this context when
</span><span class="cm">     * CONFIG_HOLES_IN_ZONE is set. This bug check is probably redundant
</span><span class="cm">     * anyway as we check zone boundaries in move_freepages_block().
</span><span class="cm">     * Remove at a later date when no bug reports exist related to
</span><span class="cm">     * grouping pages by mobility
</span><span class="cm">     */</span>
    <span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_zone</span><span class="p">(</span><span class="n">start_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">page_zone</span><span class="p">(</span><span class="n">end_page</span><span class="p">));</span>
<span class="cp">#endif
</span><span class="cp"></span>
    <span class="k">for</span> <span class="p">(</span><span class="n">page</span> <span class="o">=</span> <span class="n">start_page</span><span class="p">;</span> <span class="n">page</span> <span class="o">&lt;=</span> <span class="n">end_page</span><span class="p">;)</span> <span class="p">{</span>
        <span class="cm">/* Make sure we are not inadvertently changing nodes */</span>
        <span class="n">VM_BUG_ON_PAGE</span><span class="p">(</span><span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">zone_to_nid</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="n">page</span><span class="p">);</span>

        <span class="cm">/*
</span><span class="cm">         这个函数有两个调用者，一个是正在说明的伙伴系统的
</span><span class="cm">         move_freepages_block，这种情况能够通过下列两项
</span><span class="cm">         检查；另一个是mm/page_isolation.c中的函数，可能
</span><span class="cm">         不会通过检查？ */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid_within</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">page</span><span class="o">++</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageBuddy</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">page</span><span class="o">++</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">order</span> <span class="o">=</span> <span class="n">page_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
        <span class="cm">/* 移动内存块到相同阶数、传入的迁移类型 */</span>
        <span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span>
              <span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">order</span><span class="p">].</span><span class="n">free_list</span><span class="p">[</span><span class="n">migratetype</span><span class="p">]);</span>
        <span class="cm">/* 修改迁移类型 */</span>
        <span class="n">set_freepage_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>

        <span class="cm">/*
</span><span class="cm">         如果page没有通过上面两项检查，就会导致 1&lt;&lt;order
</span><span class="cm">         不等于 end_pfn - start_pfn */</span>
        <span class="n">page</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
        <span class="n">pages_moved</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">pages_moved</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>需要说明的是， <code>move_freepages</code> 每次都会获取page的order，order有多种可能值。</p>
<h1 id="4-总结">4. 总结</h1>
<p><code>__alloc_pages_nodemask</code> 函数首先调用 <code>get_page_from_freelist</code> ，尝试获取空闲页。<br>
为了保证函数的执行速度， <code>get_page_from_freelist</code> 会使用zlcache加快空闲页框的查找速度。</p>
<p><code>get_page_from_freelist</code> 会执行两次扫描，第一次扫描考虑所有的限制条件，包括cpuset，<strong>ALLOC_FAIR</strong> 标志，dirty限制，不考虑远程节点；第二次扫描会忽略 <strong>ALLOC_FAIR</strong> 标志，考虑远程节点。</p>
<p>对于zone中空闲页框数低于watermark的情况， <code>get_page_from_freelist</code> 调用 <code>zone_reclaim</code> ，尝试从zone中回收页框，回收流程在《mm-buddy_allocator页框回收》介绍。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Globs Guo</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2019-10-24
        
    </span>
  </p>
  
  
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/wechat.jpg">
        <span>wechat</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/alipay.jpg">
        <span>alipay</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kernel-sources/">kernel-sources</a>
          <a href="/tags/memory/">memory</a>
          <a href="/tags/buddy-allocator/">buddy-allocator</a>
          <a href="/tags/kmalloc/">kmalloc</a>
          <a href="/tags/expand/">expand</a>
          <a href="/tags/get_page_from_freelist/">get_page_from_freelist</a>
          <a href="/tags/__alloc_pages_nodemask/">__alloc_pages_nodemask</a>
          <a href="/tags/zlcache/">zlcache</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/mm-buddy_allocator_initialization/">
            <span class="next-text nav-default">mm-buddy_allocator初始化</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="GlobsGuo/utterancesRepo"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="sendtomedivh@126.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/globsguo" class="iconfont icon-github" title="github"></a>
  <a href="https://blog.globs.site/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2019 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Globs Guo</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
