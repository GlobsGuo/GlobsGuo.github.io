<!DOCTYPE html>
<html lang="en-us">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.58.3" />

    
    
    

<title>grub参数&#34;console=&#34; • Globs&#39; blog</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="grub参数&#34;console=&#34;"/>
<meta name="twitter:description" content="本文主要分析Linux内核如何处理grub参数中的console=ttyS0,115200n8部分，中间还会穿插一些 include/linux/init.h 的内容。
grub参数中的console=有多种形式，根据 Documentation/kernel-parameters.txt 文件，
 console= [KNL] Output console device and options."/>

<meta property="og:title" content="grub参数&#34;console=&#34;" />
<meta property="og:description" content="本文主要分析Linux内核如何处理grub参数中的console=ttyS0,115200n8部分，中间还会穿插一些 include/linux/init.h 的内容。
grub参数中的console=有多种形式，根据 Documentation/kernel-parameters.txt 文件，
 console= [KNL] Output console device and options." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://globsguo.github.io/posts/grub_parameters/" />
<meta property="article:published_time" content="2019-10-12T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-10-12T00:00:00+00:00" /><meta property="og:site_name" content="Globs&#39; blog" />


    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.9181f25ed2263aeb878ec6f8a84f10c4ebb16150000fca8767308880bdde5ca0.css" integrity="sha256-kYHyXtImOuuHjsb4qE8QxOuxYVAAD8qHZzCIgL3eXKA=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://globsguo.github.io/">Globs&#39; blog</a>
      </span>
      
        
        
        
        <div class="author-image">
          <img src="https://globsguo.github.io/img/photo.jpg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
      
      
      <p class="site__description">
        
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">Globs&#39; blog</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/portfolio/">
						<span>Portfolio</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>About</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	
	
	<a href="https://github.com/globsguo" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<a href="mailto:sendtomedivh@126.com" rel="me"><i class="fas fa-at fa-lg" aria-hidden="true"></i></a>
	
</section>

      </div>
    </div>
    
<div class="copyright">
  &copy; 2019 Globs Guo
  
</div>



  </div>
</div>

        <div class="content container">
            
    
<article>
  <header>
    <h1>grub参数&#34;console=&#34;</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Oct 12, 2019
    
    
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/kernel-sources">kernel sources</a>
           
      
          <a class="badge badge-tag" href="/tags/console">console</a>
           
      
          <a class="badge badge-tag" href="/tags/grub">grub</a>
           
      
          <a class="badge badge-tag" href="/tags/kernel-parameters">kernel parameters</a>
           
      
          <a class="badge badge-tag" href="/tags/cmdline">cmdline</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 12 min read
</div>


  </header>
  
  
  <div class="post">
    

<p>本文主要分析Linux内核如何处理grub参数中的console=ttyS0,115200n8部分，中间还会穿插一些  <em>include/linux/init.h</em>  的内容。</p>

<p>grub参数中的console=有多种形式，根据 <em>Documentation/kernel-parameters.txt</em> 文件，</p>

<blockquote>
<p>console=    [KNL] Output console device and options.</p>

<ul>
<li>tty&lt;n&gt;  Use the virtual console device &lt;n&gt;.</li>
<li>ttyS&lt;n&gt;[,options]</li>
<li>ttyUSB0[,options]<br />
Use the specified serial port.  The options are of  the form &ldquo;bbbbpnf&rdquo;, where &ldquo;bbbb&rdquo; is the baud rate, &ldquo;p&rdquo; is parity (&ldquo;n&rdquo;, &ldquo;o&rdquo;, or &ldquo;e&rdquo;), &ldquo;n&rdquo; is number of bits, and &ldquo;f&rdquo; is flow control (&ldquo;r&rdquo; for RTS or omit it).  Default is &ldquo;9600n8&rdquo;.</li>
<li>uart[8250],io,&lt;addr&gt;[,options]</li>
<li>uart[8250],mmio,&lt;addr&gt;[,options]<br />
Start an early, polled-mode console on the <sup>8250</sup>&frasl;<sub>16550</sub> UART at the specified I/O port or MMIO address, switching to the matching ttyS device later.  The options are the same as for ttyS, above.</li>
<li>hvc&lt;n&gt;  Use the hypervisor console device &lt;n&gt;.
This is for both Xen and PowerPC hypervisors.</li>
</ul>
</blockquote>

<p>本文主要分析参数值为ttyS&lt;n&gt;，uart[8250],io/mmio,&lt;addr&gt;[,options]的情况。</p>

<p><a id="markdown-1-cmdline的console参数" name="1-cmdline的console参数"></a></p>

<h1 id="1-cmdline的-console-参数">1. cmdline的&rdquo;console=&ldquo;参数</h1>

<p>内核启动过程中，把grub设置的cmdline保存在 <em>init/main.c</em>  的 <strong>boot_command_line</strong> 字符数组中，长度最大为256。<br />
<code>start_kernel</code>  函数在输出过 <strong>boot_command_line</strong> 信息后，会对其进行转化，分别调用 <code>parse_early_param</code>  -&gt; <code>parse_early_options</code>  -&gt; <code>parse_args(kernel/params.c)</code> -&gt; <code>do_early_param</code>  。其中， <code>parse_args</code>  函数调用 <code>parse_one</code>  完成具体的操作，各个参数如下：</p>

<pre><code class="language-C">/* @param = &quot;console&quot;
   @val = &quot;ttyS0,115200n8&quot;或者&quot;uart[8250],io,&lt;addr&gt;[,option]&quot;
   @doing = &quot;early options&quot;
   @params = NULL
   @num_params = 0
   @min_level = 0
   @max_level = 0
   @unknown = do_early_param */
static int parse_one(char *param,
             char *val,
             const char *doing,
             const struct kernel_param *params,
             unsigned num_params,
             s16 min_level,
             s16 max_level,
             int (*handle_unknown)(char *param, char *val,
                     const char *doing))
{
    unsigned int i;
    int err;

    /* Find parameter */
    for (i = 0; i &lt; num_params; i++) {
        if (parameq(param, params[i].name)) {
            if (params[i].level &lt; min_level
                || params[i].level &gt; max_level)
                return 0;
            /* No one handled NULL, so do it here. */
            if (!val &amp;&amp;
                !(params[i].ops-&gt;flags &amp; KERNEL_PARAM_FL_NOARG))
                return -EINVAL;
            pr_debug(&quot;handling %s with %p\n&quot;, param,
                params[i].ops-&gt;set);
            mutex_lock(&amp;param_lock);
            err = params[i].ops-&gt;set(val, &amp;params[i]);
            mutex_unlock(&amp;param_lock);
            return err;
        }
    }

    if (handle_unknown) {
        pr_debug(&quot;doing %s: %s='%s'\n&quot;, doing, param, val);
        return handle_unknown(param, val, doing);
    }

    pr_debug(&quot;Unknown argument '%s'\n&quot;, param);
    return -ENOENT;
}
</code></pre>

<p>最终，<code>handle_unknown(param, val, doing)</code> -&gt; <code>do_early_param(param, val, doing)</code>，</p>

<pre><code class="language-C">/* @param = &quot;console&quot;
   @val = &quot;uart[8250],io,&lt;addr&gt;[,option]&quot;
   @unused = &quot;early options&quot; */
static int __init do_early_param(char *param, char *val, const char *unused)
{
    const struct obs_kernel_param *p;
    /* __setup_start声明在init/main.c文件中，通过lds文件链接到名为
       .init.setup 的段中，这个段通过include/linux/init.h中的宏
       __setup定义.
       因此，这里会遍历所有通过__setup宏定义的函数，选择设置了early=1
       的obs_kernel_param对象，并且str=&quot;earlycon&quot;的函数，
       执行其setup_func */
    for (p = __setup_start; p &lt; __setup_end; p++) {
        if ((p-&gt;early &amp;&amp; parameq(param, p-&gt;str)) ||
            (strcmp(param, &quot;console&quot;) == 0 &amp;&amp;
             strcmp(p-&gt;str, &quot;earlycon&quot;) == 0)
        ) {
            if (p-&gt;setup_func(val) != 0)
                pr_warn(&quot;Malformed early option '%s'\n&quot;, param);
        }
    }
    /* We accept everything at this stage. */
    return 0;
}
</code></pre>

<p>设置了early标志的 <strong>struct obs_kernel_param</strong> 对象通过 <strong>early_param</strong> 宏定义，在  <em>include/linux/init.h</em>  中：</p>

<pre><code class="language-C"> #define early_param(str, fn)
    __setup_param(str, fn, fn, 1)
#define __setup_param(str, unique_id, fn, early)
    static const char __setup_str_##unique_id[] __initconst
        __aligned(1) = str;
    static struct obs_kernel_param __setup_##unique_id
        __used __section(.init.setup)
        __attribute__((aligned((sizeof(long)))))
        = { __setup_str_##unique_id, fn, early }
</code></pre>

<h1 id="2-console-uart-8250-io-mmio-addr-options">2. console=uart[8250],io/mmio,&lt;addr&gt;[,options]</h1>

<p>这种情况下，<code>do_early_param(param, val, doing)</code> 的参数<strong>param=&ldquo;console&rdquo;</strong> ， <strong>&ldquo;val=uart[8250],io/mmio,&lt;addr&gt;[,options]&rdquo;</strong> 。</p>

<p>根据定义在 <em>include/linux/serial_core.h</em>  中的</p>

<pre><code class="language-C">#define EARLYCON_DECLARE(name, func)
static int __init name##_setup_earlycon(char *buf)
{
    return setup_earlycon(buf, __stringify(name), func);
}
early_param(&quot;earlycon&quot;, name##_setup_earlycon);
</code></pre>

<p>和 <em>drivers/tty/serial/8250/8250_early.c</em>  中的 <code>EARLYCON_DECLARE(uart8250, early_serial8250_setup);</code> 和 <code>EARLYCON_DECLARE(uart, early_serial8250_setup);</code> 即</p>

<pre><code class="language-C">static int __init uart[8250]_setup_earlycon(char *buf)
{
    return setup_earlycon(buf, __stringify(uart[8250]), early_serial8250_setup);
 }
static const char __setup_str_uart[8250]_setup_earlycon[] = &quot;earlycon&quot;;
static struct obs_kernel_param __setup_uart[8250]_setup_earlycon = {
        .str = &quot;earlycon&quot;,
        .setup_func = uart[8250]_setup_earlycon,
        .early = 1,
    };
</code></pre>

<p><code>do_early_param</code>  函数中的 <code>p-&gt;setup_func(val)</code> 即 <code>uart[8250]_setup_earlycon(val)</code> -&gt; <code>setup_earlycon(&quot;uart[8250],io/mmio,&lt;addr&gt;[,options]&quot;, &quot;uart8250&quot;, early_serial8250_setup)</code> ，定义在 <em>drivers/tty/serial/earlycon.c</em>  。</p>

<pre><code class="language-C">/* @buf = &quot;uart[8250],io/mmio,&lt;addr&gt;[,options]&quot;
   @match = &quot;uart8250&quot;
   @setup = early_8250_setup */
int __init setup_earlycon(char *buf, const char *match,
              int (*setup)(struct earlycon_device *, const char *))
{
    int err;
    size_t len;
    struct uart_port *port = &amp;early_console_dev.port;
    // if条件不满足，不会返回
    if (!buf || !match || !setup)
        return 0;

    len = strlen(match);
    // if条件不满足，不会返回
    if (strncmp(buf, match, len))
        return 0;
    if (buf[len] &amp;&amp; (buf[len] != ','))
        return 0;
    //buf指向io/mmio的位置
    buf += len + 1;
    //将buf中的参数信息保存在early_console_dev对象中
    err = parse_options(&amp;early_console_dev, buf);
    /* On parsing error, pass the options buf to the setup function */
    if (!err)
        buf = NULL;

    if (port-&gt;mapbase)
        port-&gt;membase = earlycon_map(port-&gt;mapbase, 64);

    early_console_dev.con-&gt;data = &amp;early_console_dev;
    /* setup -&gt; early_serial8250_setup -&gt; init_port */
    err = setup(&amp;early_console_dev, buf);
    if (err &lt; 0)
        return err;
    // set in early_serial8250_setup, is early_serialt8250_write
    if (!early_console_dev.con-&gt;write)
        return -ENODEV;
    //控制台信息初始化完成后，调用register_console注册控制台
    register_console(early_console_dev.con);
    return 0;
}
</code></pre>

<h1 id="3-register-console">3. register_console</h1>

<p>根据代码中 <code>register_console</code>  的注释，</p>

<blockquote>
<p>The console driver calls this routine during kernel initialization to register the console printing procedure with printk() and to print any messages that were printed by the kernel before the console driver was initialized.</p>
</blockquote>

<p>控制台驱动在内核初始化时调用这个函数将控制台输出程序注册到 <code>printk</code>  函数，在控制台驱动初始化前打印内核的输出信息。</p>

<blockquote>
<p>This can happen pretty early during the boot process (because of early_printk) - sometimes before setup_arch() completes - be careful of what kernel features are used - they may not be initialised yet.</p>
</blockquote>

<p>内核可能在启动过程的很早阶段（This指的是）输出信息（由于 <code>early_printk</code>  ），有时会在 <code>setup_arch</code>  函数完成之前，注意使用的内核features，这些features可能还没有初始化。</p>

<blockquote>
<p>There are two types of consoles - bootconsoles (early_printk) and &ldquo;real&rdquo; consoles (everything which is not a bootconsole) which are handled differently.</p>

<ul>
<li>Any number of bootconsoles can be registered at any time.</li>
<li>As soon as a &ldquo;real&rdquo; console is registered, all bootconsoles will be unregistered automatically.</li>
<li>Once a &ldquo;real&rdquo; console is registered, any attempt to register a bootconsoles will be rejected</li>
</ul>
</blockquote>

<p>控制台分为两大类：bootconsoles( <code>early_printk</code>  )和真正的控制台（除了bootconsole之外的控制台），按照不同的方式处理：</p>

<ul>
<li>可以在任何时刻注册任意数量的bootconsoles</li>
<li>所有的bootconsoles都会在注册真正的控制台的同时被自动注销</li>
<li>一旦注册了真正的控制台，任何注册bootconsoles的尝试都会被拒绝</li>
</ul>

<p><code>struct console *console_drivers</code> 包含所有的已经注册的控制台驱动，通过 <code>struct console</code> 内的next指针索引。</p>

<p>针对 <strong>early_console_dev</strong> ，</p>

<pre><code class="language-C">struct earlycon_device early_console_dev = {
    .con = early_con = {
        .name = &quot;uart&quot;,
        .flags = CON_PRINTBUFFER | CON_BOOT,
        .index = -1,
    };
};
</code></pre>

<p>执行 <code>register_console</code>  时，假设 <strong>console_drivers</strong> 中没有已经注册的驱动，</p>

<pre><code class="language-C">void register_console(struct console *newcon)
{
    int i;
    unsigned long flags;
    struct console *bcon = NULL;
    struct console_cmdline *c;
    ...
    //if条件满足，但是prefered和selected都是-1
    if (preferred_console &lt; 0 || bcon || !console_drivers)
        preferred_console = selected_console;
    //未定义，不会执行
    if (newcon-&gt;early_setup)
        newcon-&gt;early_setup();

    /*
     *  See if we want to use this console driver. If we
     *  didn't select a console we take the first one
     *  that registers here.
     */
    if (preferred_console &lt; 0) {  //true
        if (newcon-&gt;index &lt; 0)  //true
            newcon-&gt;index = 0;
        if (newcon-&gt;setup == NULL ||   //true
            newcon-&gt;setup(newcon, NULL) == 0) {
            newcon-&gt;flags |= CON_ENABLED;  //set
            if (newcon-&gt;device) {    //false
                newcon-&gt;flags |= CON_CONSDEV;
                preferred_console = 0;
            }
        }
    }
    /* 现在newcon = {
               .name = &quot;uart&quot;,
               .flags = CON_PRINTBUFFER | CON_BOOT | CON_ENABLED,,
               .index = 0,
          }; */
      /*
     *  See if this console matches one we selected on
     *  the command line.
     */
    for (i = 0, c = console_cmdline;
         i &lt; MAX_CMDLINECONSOLES &amp;&amp; c-&gt;name[0];
         i++, c++) {
        if (strcmp(c-&gt;name, newcon-&gt;name) != 0)
            continue;   //控制台名称不匹配
        if (newcon-&gt;index &gt;= 0 &amp;&amp;
            newcon-&gt;index != c-&gt;index)
            continue;   //控制台名称匹配，设备index不匹配
        if (newcon-&gt;index &lt; 0)   //false
            newcon-&gt;index = c-&gt;index;

        if (_braille_register_console(newcon, c))   //false
            return;

        if (newcon-&gt;setup &amp;&amp;
            newcon-&gt;setup(newcon, console_cmdline[i].options) != 0)
            break;      //false
        /* 根据命令行的控制台信息更新newcon参数 */
        newcon-&gt;flags |= CON_ENABLED;
        newcon-&gt;index = c-&gt;index;
        if (i == selected_console) {    //false
            newcon-&gt;flags |= CON_CONSDEV;
            preferred_console = selected_console;
        }
        break;
    }
    ...
     /*
     *  Put this console in the list - keep the
     *  preferred driver at the head of the list.
     */
    console_lock();
    //console_drivers = NULL
    if ((newcon-&gt;flags &amp; CON_CONSDEV) || console_drivers == NULL) {
        newcon-&gt;next = console_drivers;
        console_drivers = newcon;
        if (newcon-&gt;next)   //false
            newcon-&gt;next-&gt;flags &amp;= ~CON_CONSDEV;
    } else {
        newcon-&gt;next = console_drivers-&gt;next;
        console_drivers-&gt;next = newcon;
    }
    if (newcon-&gt;flags &amp; CON_PRINTBUFFER) {  //true
        /*
         * console_unlock(); will print out the buffered messages
         * for us. */
        raw_spin_lock_irqsave(&amp;logbuf_lock, flags);
        console_seq = syslog_seq;
        console_idx = syslog_idx;
        console_prev = syslog_prev;
        raw_spin_unlock_irqrestore(&amp;logbuf_lock, flags);
        /*
         * We're about to replay the log buffer.  Only do this to the
         * just-registered console to avoid excessive message spam to
         * the already-registered consoles. */
        exclusive_console = newcon;
    }
    console_unlock();
    console_sysfs_notify();
    ...
    //这是一个boot console
    pr_info(&quot;%sconsole [%s%d] enabled\n&quot;,
        (newcon-&gt;flags &amp; CON_BOOT) ? &quot;boot&quot; : &quot;&quot; ,
        newcon-&gt;name, newcon-&gt;index);

}
</code></pre>

<p>至此，通过 <strong>console=uart[8250],io/mmio,&lt;addr&gt;[,options]</strong> 设置的控制台已经注册到内核中， 可以正常工作。</p>

<p>正如内核中的注释所说：
&gt; Start an early, polled-mode console on the <sup>8250</sup>&frasl;<sub>16550</sub> UART at the specified I/O port or MMIO address, switching to the matching ttyS device later. The options are the same as for ttyS, above.</p>

<p>这种类型的控制台是轮询模式的，之后会切换到对应的 <strong>ttyS&lt;n&gt;</strong> 设备，并且采用相同的参数信息。发生在 <code>serial8250_console_init</code>  执行时调用 <code>register_console</code>  ，进而调用 <code>serial8250_conosle_early_setup</code>  -&gt; <code>serial8250_find_port_for_earlycon</code>  ，下一部分内容中 会有详细介绍。</p>

<h1 id="4-console-ttys-n-options">4. console=ttyS&lt;n&gt;[,options]</h1>

<p>这种类型的控制台并不通过 <code>early_param</code>  宏定义，没有设置 <strong>early</strong> 标志，因此不会在 <code>do_early_param</code>  函数中调用。</p>

<h2 id="4-1-console-initcall">4.1. console_initcall</h2>

<p><code>console_initcall</code>  宏有两种定义，一种是 <strong>MODULE</strong> 下的定义：<code>#define console_initcall(fn) module_init(fn)</code>， <code>module_init</code>  的定义为：</p>

<pre><code class="language-C">#define module_init(initfn)
    static inline initcall_t __inittest(void)
    { return initfn; }  
    int init_module(void) __attribute__((alias(#initfn)));
</code></pre>

<p><code>initcall_t</code>  即<code>typedef int (*initcall_t)(void);</code> ，于是，<code>console_initcall(serial8250_console_init);</code> 就变成了</p>

<pre><code class="language-C">static inline int _inittest(void) { return serial8250_console_init; }
int init_module(void) __attribute__((alias(&quot;serial8250_console_init&quot;));
</code></pre>

<p><code>__attribute__((alias(&quot;serial8250_console_init&quot;))</code> 这个GCC函数属性alias告诉编译器，把 <code>serial8250_console_init</code>  用 <code>init_module</code>  代替。</p>

<h3 id="4-1-1-inbox-mode">4.1.1. inbox mode</h3>

<p>还有一种是inbox mode（make menuconfig时直接选择某个模块，而不是M），这种情况下</p>

<pre><code class="language-C">#define console_initcall(fn)
    static initcall_t __initcall_##fn
    __used __section(.con_initcall.init) = fn
</code></pre>

<p><code>console_initcall(serial8250_console_init);</code> (  <em>drivers/tty/serial/8250/8250_core.c</em>  )即</p>

<pre><code class="language-C">static int __initcall_serial8250_console_init __used __section(.con_initcall.init) = serial8250_console_init;
</code></pre>

<p>定义了一个名为 <code>__initcall_serial8250_console_init</code>  的函数，具有used属性（code must be emitted even if it appears that function is not referenced），放在名为 <strong>.con_initcall.init</strong> 的段中。</p>

<p>根据lds的内容，这个 <strong>.con_initcall.init</strong> 段会被链接到  <em>include/linux/init.h</em>  的 <code>__con_initcall_start</code>  指向的地址（也可以查看内核源码目录下的System.map文件，搜索名为  <strong>__initcall_serial8250_console_init</strong>  函数），然后在  <em>drivers/tty/tty_io.c</em>  中的 <code>console_init</code>  函数调用。</p>

<p>完整的函数调用路径为： <code>start_kernel</code>  (  <em>init/main.c</em>  )  -&gt; <code>console_init</code>  -&gt; <code>__initcall_serial8250_console_init</code>  -&gt; <code>serialt8250_console_init</code>  。</p>

<h3 id="4-1-2-serial8250-console">4.1.2. serial8250_console</h3>

<p><code>serial8250_console_init</code>  函数首先调用 <code>serial8250_isa_init_ports</code>  根据  <em>arch/x86/include/asm/serial.h</em>  中的 <strong>SERIAL_PORT_DFNS</strong> 信息对 <strong>struct uart_8250_port serial8250_ports</strong>  结构体对象进行初始化，然后再调用  <em>kernel/printk/printk.c</em>  -&gt; <code>register_console(&amp;serial8250_console)</code> 注册8250控制台到内核。</p>

<pre><code class="language-C">static struct console serial8250_console = {
    .name       = &quot;ttyS&quot;,
    .write      = serial8250_console_write,
    .device     = uart_console_device,
    .setup      = serial8250_console_setup,
    .early_setup    = serial8250_console_early_setup,
    .flags      = CON_PRINTBUFFER | CON_ANYTIME,
    .index      = -1,
    .data       = &amp;serial8250_reg,
};
</code></pre>

<p>由于 <strong>serial8250_console</strong> 之前没有注册过，也不具有 <strong>CON_BOOT</strong> 标志，因此会直接执行</p>

<pre><code class="language-C">void register_console(struct console *newcon)
{
    int i;
    unsigned long flags;
    struct console *bcon = NULL;
    struct console_cmdline *c;
    ...
    /* 如果有console=uart参数，此时console_drivers已经包含uart类型的
       控制台，而且是一个bootconsole，下列两个if条件都会满足 */
    if (console_drivers &amp;&amp; console_drivers-&gt;flags &amp; CON_BOOT)
        bcon = console_drivers;

    if (preferred_console &lt; 0 || bcon || !console_drivers)
        preferred_console = selected_console;
    // serial8250_console_early_setup
    if (newcon-&gt;early_setup)
        newcon-&gt;early_setup();
</code></pre>

<p><code>newcon-&gt;early_setup()</code> -&gt; <code>serial8250_console_early_setup</code>  -&gt; <code>serial8250_find_port_for_earlycon</code></p>

<pre><code class="language-C">int serial8250_find_port_for_earlycon(void)
{
    /* 如果设置了uart控制台，这里的early_device就是
       struct earlycon_device early_console_dev，
      在函数early_serial8250_serup里设置，否则就是NULL */
    struct earlycon_device *device = early_device;

    /* 如果early_device为NULL，这里port就为NULL，
       在之后的代码语句会直接返回-ENODEV, 否则就根据
       early_device寻找用于控制台的串口信息 */
    struct uart_port *port = device ? &amp;device-&gt;port : NULL;
    int line;
    int ret;

    if (!port || (!port-&gt;membase &amp;&amp; !port-&gt;iobase))
        return -ENODEV;

    /* 查找和serial8250_ports中保存的串口信息相匹配的
       串口line，匹配包括串口的iotype和io地址 */
    line = serial8250_find_port(port);
    if (line &lt; 0)
        return -ENODEV;
    /* 如果console_cmdline数组中已有匹配的uart8250控制台
       信息，将其更新为ttySn信息 */
    ret = update_console_cmdline(&quot;uart&quot;, 8250,
                 &quot;ttyS&quot;, line, device-&gt;options);
    /* 如果console_cmdline数组中已有匹配的uart控制台信息
       将其更新为ttySn信息 */
    if (ret &lt; 0)
        ret = update_console_cmdline(&quot;uart&quot;, 0,
                     &quot;ttyS&quot;, line, device-&gt;options);

    return ret;
}

int update_console_cmdline(char *name, int idx, char *name_new, int idx_new, char *options)
{
    struct console_cmdline *c;
    int i;
    /* console_cmdline是struct console_cmdline对象数组，
       保存系统中所有的根据cmdline信息构建的控制台信息，
       即grub参数console=，最多为8 */
    for (i = 0, c = console_cmdline;
         i &lt; MAX_CMDLINECONSOLES &amp;&amp; c-&gt;name[0];
         i++, c++)
        /* 如果name和index匹配，就用新的name替换旧的name，
           并设置option，更新index信息，返回其在console_cmdline
           的数组下标。 */
        if (strcmp(c-&gt;name, name) == 0 &amp;&amp; c-&gt;index == idx) {
            strlcpy(c-&gt;name, name_new, sizeof(c-&gt;name));
            c-&gt;name[sizeof(c-&gt;name) - 1] = 0;
            c-&gt;options = options;
            c-&gt;index = idx_new;
            return i;
        }
    /* not found */
    return -1;
}
</code></pre>

<p><code>newcon-&gt;early_setup()</code> 返回之后， <code>register_console</code>  函数会继续执行，</p>

<pre><code class="language-C">    if (preferred_console &lt; 0) {    //假设为true
        if (newcon-&gt;index &lt; 0)  //true
            newcon-&gt;index = 0;
        if (newcon-&gt;setup == NULL ||    //false
            /* serial8250_console_setup
               newcon = serial8250_console */
            newcon-&gt;setup(newcon, NULL) == 0) { //true
            newcon-&gt;flags |= CON_ENABLED;
            if (newcon-&gt;device) { //true
                newcon-&gt;flags |= CON_CONSDEV;
                preferred_console = 0;
            }
        }
    }
</code></pre>

<p><code>serial8250_console_setup</code>  会调用 <code>uart_parse_options</code>  和 <code>uart_set_options</code>  函数先把传入的串口参数信息转化，然后设置到串口信息中。这里，由于串口的参数为NULL， <code>uart_set_options</code>  函数会直接采用默认值9600n8，无flow control设置串口信息。</p>

<p>如果newcon和通过cmdline选择的控制台匹配， <code>register_console</code>  根据cmdline的控制台信息设置newcon：</p>

<pre><code class="language-C">    /* 如果console_cmdline中包含和newcon匹配的控制台，
       用控制台的参数信息重新配置newcon
       但是这样有一个问题，如果上面的代码preferred&lt;0成立
       会设置newcon-&gt;index=0；
       假设console=ttyS1，则console_cmdline的index不会和
       newcon-&gt;index相等，就无法根据console_cmdline的信息
       设置控制台参数 */
    for (i = 0, c = console_cmdline;
         i &lt; MAX_CMDLINECONSOLES &amp;&amp; c-&gt;name[0];
         i++, c++) {
        if (strcmp(c-&gt;name, newcon-&gt;name) != 0)
            continue;
        if (newcon-&gt;index &gt;= 0 &amp;&amp;
            newcon-&gt;index != c-&gt;index)
            continue;
        if (newcon-&gt;index &lt; 0)
            newcon-&gt;index = c-&gt;index;

        if (_braille_register_console(newcon, c))
            return;

        if (newcon-&gt;setup &amp;&amp;
            newcon-&gt;setup(newcon, console_cmdline[i].options) != 0)
            break;
        newcon-&gt;flags |= CON_ENABLED;
        newcon-&gt;index = c-&gt;index;
        if (i == selected_console) {
            newcon-&gt;flags |= CON_CONSDEV;
            preferred_console = selected_console;
        }
        break;
    }
    ...
    //如果newcon是非bootconsole，释放所有已经注册的bootconsoles
    if (bcon &amp;&amp;
        ((newcon-&gt;flags &amp; (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &amp;&amp;
        !keep_bootcon) {
        /* We need to iterate through all boot consoles, to make
         * sure we print everything out, before we unregister them.
         */
        for_each_console(bcon)
            if (bcon-&gt;flags &amp; CON_BOOT)
                unregister_console(bcon);
    }
</code></pre>

<h1 id="5-preferred-console">5. preferred_console</h1>

<p>下面，追踪一下变量 <strong>selected_console</strong> 和 <strong>preferred_console</strong> ，这两个都是定义在  <em>kernel/printk/printk.c</em>  中的静态变量。</p>

<p><strong>preferred_console</strong> 只有在函数 <code>register_console</code>  中才会修改，而且赋值语句的右值都是 <strong>selected_console</strong> ； <strong>selected_console</strong> 的赋值都在 <code>__add_preferred_console</code>  函数。</p>

<p>函数的逆调用路径为： <code>__add_preferred_console</code>  &lt;- <code>console_setup</code>  &lt;- <code>obsolete_checksetup</code>  （ <em>init/main.c</em>  ) &lt;- <code>unknown_bootoption</code>  &lt;- <code>parse_args</code>  &lt;- <code>start_kernel</code>  。</p>

<p>先看 <code>start_kernel</code>  函数：</p>

<pre><code class="language-C">    ...
    pr_notice(&quot;Kernel command line: %s\n&quot;, boot_command_line);
    // console=uart 在这个函数处理，创建earlycon
    parse_early_param();
    // console=ttyS&lt;n&gt; 在这个函数处理，添加preferred console？
    after_dashes = parse_args(&quot;Booting kernel&quot;,
                  static_command_line, __start___param,
                  __stop___param - __start___param,
                  -1, -1, &amp;unknown_bootoption);
    ...
    //serial8250_conosole_init调用，根据命令行参数更新控制台信息
    console_init();
    ...
</code></pre>

<p>查看System.map文件，  <strong><strong>start</strong>_param</strong>  和  <strong><strong>stop</strong>_param</strong>  之间包含所有grub参数，查看lds文件，  <strong><strong>start</strong>_param</strong>  和  <strong><strong>stop</strong>_param</strong>  指向名为  <strong>__param</strong>  的段。
只有  <em>include/linux/moduleparam.h</em>  中用到了这个段：</p>

<pre><code class="language-C">#define __module_param_call(prefix, name, ops, arg, perm, level)
    /* Default value instead of permissions? */
    static const char __param_str_##name[] = prefix #name;
    static struct kernel_param __moduleparam_const __param_##name
    __used
    __attribute__ ((unused,__section__ (&quot;__param&quot;),aligned(sizeof(void *))))
    = { __param_str_##name, ops, VERIFY_OCTAL_PERMISSIONS(perm),
    level, { arg } }
</code></pre>

<p>所有的kernel parameters（<em>Documentation/kernel-parameters</em> )都直接或者间接通过这个宏定义，但是其中没有与“console”匹配的参数，所以 <code>parse_one</code>  函数还是会执行 <code>handle_unknown</code>  ，即 <code>unknown_bootoption</code>  -&gt; <code>obsolete_checksetup</code>  。</p>

<p>在执行 <code>obsolete_checksetup</code>  前， <code>unknown_bootoption</code>  会先调用 <code>repair_env_string</code>  , 将参数 <code>param</code>  和 <code>value</code>   拼接成 &ldquo;param=value&rdquo;的形式，之后将其作为参数传递给 <code>obsolete_checksetup</code>  函数。</p>

<p>在解析 <code>obsolete_checksetup</code>  函数之前，先说明  <em>include/linux/init.h</em>  中的  <strong>__setup</strong>  宏：</p>

<pre><code class="language-C">#define __setup(str, fn)
    __setup_param(str, fn, fn, 0)
</code></pre>

<p>和 <strong>early_param</strong> 宏类似,，  <strong>__setup</strong>  宏也通过  <strong>__setup_param</strong>  宏定义，只是传入的 <strong>early</strong> 参数为0。因此，  <em>kernel/printk/printk.c</em>  中的 <code>__setup(&quot;console=&quot;, console_setup);</code> ，即</p>

<pre><code class="language-C">static const char __setup__str_console_setup[] = &quot;console=&quot;;
static struct obs_kernel_param __setup_console_setup = {
    __setup_str_console_setup =&gt; &quot;console=&quot;,
    console_setup,
    0
};
</code></pre>

<p>这样，在执行 <code>obsolete_checksetup</code>  函数时，</p>

<pre><code class="language-C">// @line=&quot;console=ttyS0,115200n8&quot;
static int __init obsolete_checksetup(char *line)
{
    const struct obs_kernel_param *p;
    int had_early_param = 0;

    /* __setup_start声明在init/main.c中，
      根据lds文件，__setup_start指向section(.init.setup)
      也可以根据System.map文件，查看__setup_start -
      __setup_end 之间的所有函数.
      这里，会遍历所有定义在section(.init.setup)中的函数 */
    p = __setup_start;
    do {
        int n = strlen(p-&gt;str);
        /* 这里，定义在kernel/printk/printk.c
        中的 struct obs_kernel_param
        __setup_console_setup对象的
        str成员就能够通过检查 */
        if (parameqn(line, p-&gt;str, n)) {    //true
            if (p-&gt;early) {     //false
                /* Already done in parse_early_param?
                 * (Needs exact match on param part).
                 * Keep iterating, as we can have early
                 * params and __setups of same names 8( */
                if (line[n] == '\0' || line[n] == '=')
                    had_early_param = 1;
            } else if (!p-&gt;setup_func) {    //false
                pr_warn(&quot;Parameter %s is obsolete, ignored\n&quot;,
                    p-&gt;str);
                return 1;
            /* 调用console_setup函数，将param对应的value作为参数 */
            } else if (p-&gt;setup_func(line + n))
                return 1;
        }
        p++;
    } while (p &lt; __setup_end);

    return had_early_param;
}
</code></pre>

<p>因此，接下来会调用 <code>console_setup</code>  (  <em>kernel/printk/printk.c</em>  )函数：</p>

<pre><code class="language-C">/* @str=&quot;ttyS0,115200n8&quot; */
static int __init console_setup(char *str)
{
    char buf[sizeof(console_cmdline[0].name) + 4]; /* 4 for index */
    char *s, *options, *brl_options = NULL;
    int idx;

    if (_braille_console_setup(&amp;str, &amp;brl_options)) //false
        return 1;

    /*
     * Decode str into name, index, options.
     */
    if (str[0] &gt;= '0' &amp;&amp; str[0] &lt;= '9') {
        strcpy(buf, &quot;ttyS&quot;);
        strncpy(buf + 4, str, sizeof(buf) - 5);
    } else {
        /* sizeof(buf)=12
           buf=&quot;ttyS0,11520&quot; */
        strncpy(buf, str, sizeof(buf) - 1);
    }
    buf[sizeof(buf) - 1] = 0;
    if ((options = strchr(str, ',')) != NULL)
        //str=&quot;ttyS0&quot; &quot;115200&quot;
        *(options++) = 0;
    for (s = buf; *s; s++)
        if ((*s &gt;= '0' &amp;&amp; *s &lt;= '9') || *s == ',')
            break;
    idx = simple_strtoul(s, NULL, 10);
    *s = 0;

    /* buf = ttyS, idx = 0, options = 115200n8 */
    __add_preferred_console(buf, idx, options, brl_options);
    console_set_on_cmdline = 1;
    return 1;
}
</code></pre>

<p>接下来调用 <code>__add_preferred_console</code>  函数，</p>

<pre><code class="language-C">/* @name=&quot;ttyS&quot;
   @idx=0
   @options=&quot;115200n8&quot;
   @brl_options=NULL  */
static int __add_preferred_console(char *name, int idx, char *options,
                   char *brl_options)
{
    struct console_cmdline *c;
    int i;

    /*
     *  See if this tty is not yet registered, and
     *  if we have a slot free.
     */
    for (i = 0, c = console_cmdline;
         i &lt; MAX_CMDLINECONSOLES &amp;&amp; c-&gt;name[0];
         i++, c++) {
         //如果console_cmdline中包含匹配的控制台，设置selected_console
        if (strcmp(c-&gt;name, name) == 0 &amp;&amp; c-&gt;index == idx) {
            if (!brl_options)
                selected_console = i;
            return 0;
        }
    }
    if (i == MAX_CMDLINECONSOLES)
        return -E2BIG;
    //console_cmdline中没有匹配的控制台，但是有空闲的slot
    if (!brl_options)
        selected_console = i;
    strlcpy(c-&gt;name, name, sizeof(c-&gt;name));
    c-&gt;options = options;
    braille_set_options(c, brl_options);

    c-&gt;index = idx;
    return 0;
}
</code></pre>

<p><strong>console_cmdline</strong> 变量定义在  <em>kernel/printk/printk.c</em>  中的static  <strong>struct console_cmdline</strong> 对象的数组，最多包含8个元素，只有 <code>__add_preferred_console</code>  函数会对其进行修改操作。</p>

<p>因此，对于kernel param <strong>&ldquo;console=uart[8250],io/mmio,&lt;addr&gt;[,options]&rdquo;</strong> ，执行 <code>register_console</code>  函数时，<strong>selected_console=-1</strong>；对于 <strong>&ldquo;console=ttyS&lt;n&gt;[,options]&rdquo;</strong> ，执行 <code>__add_preferred_console</code>  函数时， <strong>console_cmdline</strong> 变量中没有元素，因此会把新增的控制台保存在数组中的一个元素，执行 <code>register_console</code>  时 <strong>selected_console=0</strong>  。</p>

  </div>
  

<div class="navigation navigation-single">
    
    <a href="/posts/memory_policy/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">Linux Memory Policy</span>
    </a>
    
    
    <a href="/posts/driver_model/" class="navigation-next">
      <span class="navigation-tittle">driver model</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  


<div class="post__related">
    
    <h2>Related Articles</h2>
    <ul class="related-posts">
        
<li>
  <span class="list__title--small">
    <a href="/posts/memory_management/" >Memory Management Initialization</a>
      
      <time class="pull-right hidden-tablet">Oct 12, 2019</time>
      
  </span>
</li>

<li>
  <span class="list__title--small">
    <a href="/posts/mm-slab/" >mm-slab</a>
      
      <time class="pull-right hidden-tablet">Sep 19, 2019</time>
      
  </span>
</li>

<li>
  <span class="list__title--small">
    <a href="/posts/printk/" >printk函数</a>
      
  </span>
</li>


    </ul>
</div>



  
    
        <script src="https://utteranc.es/client.js"
        repo="https://github.com/globsguo/utterancesRepo"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
    


</article>


        </div>
        
    

<script defer src="https://use.fontawesome.com/releases/v5.5.0/js/all.js" integrity="sha384-GqVMZRt5Gn7tB9D9q7ONtcp4gtHIUEW/yG7h98J7IpE3kpi+srfFyyB/04OV6pG0" crossorigin="anonymous"></script>


    
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
        
    
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    




    



    </body>
</html>
